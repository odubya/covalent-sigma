{"version":3,"file":"400.5b5c3119.iframe.bundle.js","mappings":";;;;AA+EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;;;;;AAOA;;;AAIA;;AAKA;AAEA;ACpCA;AAEA;AA4BA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AASA;AAEA;;ACnGA;AACA;;AAEA;;;AAGA;AACA;AACA;AAEA;;;AAgBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAGA;;;AAQA;;AAGA;;;AAgBA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAGA;AC8CA;;;;;;;AAOA;;;;;;AAMA;;;;;;;;;;;AAYA;AAGA;;;;;;ACtIA;AAMA;AACA;;;AAGA;AACA;;;;AAMA;AC/BA;;;AAGA;AAEA;;ACpCA;;AAGA;;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAKA;;;ACIA;AACA;AACA;AACA;;;AAGA;AACA;;;;AAIA;;;;;;AAMA;;;;;;AAOA;ACnEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;;ACoGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AAMA;AAGA;AC9EA;AACA;AACA;AACA;;AAMA;AAGA;AAYA;;AAGA;;;AAMA;;AAKA;AAEA;;;;;;;AAaA;AC5GA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AC6BA;AACA;AACA;AACA;AACA;;AAGA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAIA;AChEA;;;;;;AAOA;ACsDA;AACA;AA2EA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AAEA;AC5BA;AACA;;ACjDA;;;AAGA;AACA;;AAEA;AACA;;;;;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA;;;;;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AASA;;AAOA;AACA;;AAEA;AAPA;;AAgBA;AACA;AALA;AAmBA;AAEA;;AAWA;AACA;AC5LA;AACA;AACA;AACA;AACA;AACA;;AASA;AACA;AACA;AACA;AACA;AAEA;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAOA;AAFA;;AAwCA;AACA;AACA;AACA;AACA;AACA;;;AAIA;;;;AAMA;;;AAIA;;AC/HA;AACA;AACA;AACA;AACA;AAEA;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAyBA;;;AAIA;;AA6BA;AACA;AACA;AACA;AACA;AACA;;;AAIA;;;;;;AC7HA;;;AAIA;ACuGA;AChHA;;AAEA;;AAEA;AACA;;;AAIA;;;ACcA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;;;;;AAOA;AACA;AACA;;AAGA;;AAaA;AACA;;AAEA;AACA;;;AAIA;;;;AAQA;;;;AAQA;;;;AAOA;;;;AAUA;;;;AAQA;;;ACtHA;AACA;AACA;AACA;AACA;AACA;;;;AAKA;;ACLA;AACA;;;AAIA;ACRA;AAGA;;AAGA;AC6BA;AAKA;;AAIA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAGA;AACA;AAOA;ACnDA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;;AAWA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;ACsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;;AAeA;;AAKA;AACA;;AAEA;AALA;;AAcA;AACA;AAJA;AAwCA;;AAoBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAEA;;;AAgBA;AACA;AACA;AACA;AANA;;AAcA;AC9PA;;;;AAIA;AACA;;AAEA;;;;;;AAMA;;;AAIA","sources":["webpack://@covalent/components/./node_modules/@material/mwc-button/mwc-button-base.js","webpack://@covalent/components/./node_modules/@material/mwc-checkbox/mwc-checkbox-base.js","webpack://@covalent/components/./node_modules/@material/mwc-circular-progress/mwc-circular-progress-base.js","webpack://@covalent/components/./node_modules/@material/mwc-dialog/mwc-dialog-base.js","webpack://@covalent/components/./node_modules/@material/mwc-drawer/mwc-drawer-base.js","webpack://@covalent/components/./node_modules/@material/mwc-formfield/mwc-formfield-base.js","webpack://@covalent/components/./node_modules/@material/mwc-icon-button/mwc-icon-button-base.js","webpack://@covalent/components/./node_modules/@material/mwc-linear-progress/mwc-linear-progress-base.js","webpack://@covalent/components/./node_modules/@material/mwc-list/mwc-check-list-item-base.js","webpack://@covalent/components/./node_modules/@material/mwc-list/mwc-list-base.js","webpack://@covalent/components/./node_modules/@material/mwc-list/mwc-list-item-base.js","webpack://@covalent/components/./node_modules/@material/mwc-list/mwc-radio-list-item-base.js","webpack://@covalent/components/./node_modules/@material/mwc-menu/mwc-menu-surface-base.js","webpack://@covalent/components/./node_modules/@material/mwc-menu/mwc-menu-base.js","webpack://@covalent/components/./node_modules/@material/mwc-notched-outline/mwc-notched-outline-base.js","webpack://@covalent/components/./node_modules/@material/mwc-radio/mwc-radio-base.js","webpack://@covalent/components/./node_modules/@material/mwc-ripple/mwc-ripple-base.js","webpack://@covalent/components/./node_modules/@material/mwc-select/mwc-select-base.js","webpack://@covalent/components/./node_modules/@material/mwc-slider/slider-base.js","webpack://@covalent/components/./node_modules/@material/mwc-slider/slider-range-base.js","webpack://@covalent/components/./node_modules/@material/mwc-slider/slider-single-base.js","webpack://@covalent/components/./node_modules/@material/mwc-snackbar/accessible-snackbar-label-directive.js","webpack://@covalent/components/./node_modules/@material/mwc-snackbar/mwc-snackbar-base.js","webpack://@covalent/components/./node_modules/@material/mwc-switch/mwc-switch-base.js","webpack://@covalent/components/./node_modules/@material/mwc-tab-scroller/mwc-tab-scroller-base.js","webpack://@covalent/components/./node_modules/@material/mwc-tab-bar/mwc-tab-bar-base.js","webpack://@covalent/components/./node_modules/@material/mwc-tab-indicator/mwc-tab-indicator-base.js","webpack://@covalent/components/./node_modules/@material/mwc-tab/mwc-tab-base.js","webpack://@covalent/components/./node_modules/@material/mwc-textarea/mwc-textarea-base.js","webpack://@covalent/components/./node_modules/@material/mwc-textfield/mwc-textfield-base.js","webpack://@covalent/components/./node_modules/@material/mwc-top-app-bar/mwc-top-app-bar-base-base.js"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-icon/mwc-icon';\nimport '@material/mwc-ripple/mwc-ripple';\nimport { ariaProperty } from '@material/mwc-base/aria-property';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers';\nimport { html, LitElement } from 'lit';\nimport { eventOptions, property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\n/** @soyCompatible */\nexport class ButtonBase extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.raised = false;\n        this.unelevated = false;\n        this.outlined = false;\n        this.dense = false;\n        this.disabled = false;\n        this.trailingIcon = false;\n        this.fullwidth = false;\n        this.icon = '';\n        this.label = '';\n        this.expandContent = false;\n        this.shouldRenderRipple = false;\n        this.rippleHandlers = new RippleHandlers(() => {\n            this.shouldRenderRipple = true;\n            return this.ripple;\n        });\n    }\n    /** @soyTemplate */\n    renderOverlay() {\n        return html ``;\n    }\n    /** @soyTemplate */\n    renderRipple() {\n        const filled = this.raised || this.unelevated;\n        return this.shouldRenderRipple ?\n            html `<mwc-ripple class=\"ripple\" .primary=\"${!filled}\" .disabled=\"${this.disabled}\"></mwc-ripple>` :\n            '';\n    }\n    focus() {\n        const buttonElement = this.buttonElement;\n        if (buttonElement) {\n            this.rippleHandlers.startFocus();\n            buttonElement.focus();\n        }\n    }\n    blur() {\n        const buttonElement = this.buttonElement;\n        if (buttonElement) {\n            this.rippleHandlers.endFocus();\n            buttonElement.blur();\n        }\n    }\n    /** @soyTemplate */\n    getRenderClasses() {\n        return {\n            'mdc-button--raised': this.raised,\n            'mdc-button--unelevated': this.unelevated,\n            'mdc-button--outlined': this.outlined,\n            'mdc-button--dense': this.dense,\n        };\n    }\n    /**\n     * @soyTemplate\n     * @soyAttributes buttonAttributes: #button\n     * @soyClasses buttonClasses: #button\n     */\n    render() {\n        return html `\n      <button\n          id=\"button\"\n          class=\"mdc-button ${classMap(this.getRenderClasses())}\"\n          ?disabled=\"${this.disabled}\"\n          aria-label=\"${this.label || this.icon}\"\n          aria-haspopup=\"${ifDefined(this.ariaHasPopup)}\"\n          @focus=\"${this.handleRippleFocus}\"\n          @blur=\"${this.handleRippleBlur}\"\n          @mousedown=\"${this.handleRippleActivate}\"\n          @mouseenter=\"${this.handleRippleMouseEnter}\"\n          @mouseleave=\"${this.handleRippleMouseLeave}\"\n          @touchstart=\"${this.handleRippleActivate}\"\n          @touchend=\"${this.handleRippleDeactivate}\"\n          @touchcancel=\"${this.handleRippleDeactivate}\">\n        ${this.renderOverlay()}\n        ${this.renderRipple()}\n        <span class=\"leading-icon\">\n          <slot name=\"icon\">\n            ${this.icon && !this.trailingIcon ? this.renderIcon() : ''}\n          </slot>\n        </span>\n        <span class=\"mdc-button__label\">${this.label}</span>\n        <span class=\"slot-container ${classMap({\n            flex: this.expandContent\n        })}\">\n          <slot></slot>\n        </span>\n        <span class=\"trailing-icon\">\n          <slot name=\"trailingIcon\">\n            ${this.icon && this.trailingIcon ? this.renderIcon() : ''}\n          </slot>\n        </span>\n      </button>`;\n    }\n    /** @soyTemplate */\n    renderIcon() {\n        return html `\n    <mwc-icon class=\"mdc-button__icon\">\n      ${this.icon}\n    </mwc-icon>`;\n    }\n    handleRippleActivate(evt) {\n        const onUp = () => {\n            window.removeEventListener('mouseup', onUp);\n            this.handleRippleDeactivate();\n        };\n        window.addEventListener('mouseup', onUp);\n        this.rippleHandlers.startPress(evt);\n    }\n    handleRippleDeactivate() {\n        this.rippleHandlers.endPress();\n    }\n    handleRippleMouseEnter() {\n        this.rippleHandlers.startHover();\n    }\n    handleRippleMouseLeave() {\n        this.rippleHandlers.endHover();\n    }\n    handleRippleFocus() {\n        this.rippleHandlers.startFocus();\n    }\n    handleRippleBlur() {\n        this.rippleHandlers.endFocus();\n    }\n}\nButtonBase.shadowRootOptions = { mode: 'open', delegatesFocus: true };\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-haspopup' })\n], ButtonBase.prototype, \"ariaHasPopup\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], ButtonBase.prototype, \"raised\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], ButtonBase.prototype, \"unelevated\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], ButtonBase.prototype, \"outlined\", void 0);\n__decorate([\n    property({ type: Boolean })\n], ButtonBase.prototype, \"dense\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], ButtonBase.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, attribute: 'trailingicon' })\n], ButtonBase.prototype, \"trailingIcon\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], ButtonBase.prototype, \"fullwidth\", void 0);\n__decorate([\n    property({ type: String })\n], ButtonBase.prototype, \"icon\", void 0);\n__decorate([\n    property({ type: String })\n], ButtonBase.prototype, \"label\", void 0);\n__decorate([\n    property({ type: Boolean })\n], ButtonBase.prototype, \"expandContent\", void 0);\n__decorate([\n    query('#button')\n], ButtonBase.prototype, \"buttonElement\", void 0);\n__decorate([\n    queryAsync('mwc-ripple')\n], ButtonBase.prototype, \"ripple\", void 0);\n__decorate([\n    state()\n], ButtonBase.prototype, \"shouldRenderRipple\", void 0);\n__decorate([\n    eventOptions({ passive: true })\n], ButtonBase.prototype, \"handleRippleActivate\", null);\n//# sourceMappingURL=mwc-button-base.js.map","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-ripple/mwc-ripple';\nimport { ariaProperty } from '@material/mwc-base/aria-property';\nimport { FormElement } from '@material/mwc-base/form-element';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers';\nimport { html } from 'lit';\nimport { eventOptions, property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\n/** @soyCompatible */\nexport class CheckboxBase extends FormElement {\n    constructor() {\n        super(...arguments);\n        this.checked = false;\n        this.indeterminate = false;\n        this.disabled = false;\n        this.name = '';\n        this.value = 'on';\n        /**\n         * Touch target extends beyond visual boundary of a component by default.\n         * Set to `true` to remove touch target added to the component.\n         * @see https://material.io/design/usability/accessibility.html\n         */\n        this.reducedTouchTarget = false;\n        this.animationClass = '';\n        this.shouldRenderRipple = false;\n        this.focused = false;\n        // MDC Foundation is unused\n        this.mdcFoundationClass = undefined;\n        this.mdcFoundation = undefined;\n        this.rippleElement = null;\n        this.rippleHandlers = new RippleHandlers(() => {\n            this.shouldRenderRipple = true;\n            this.ripple.then((v) => this.rippleElement = v);\n            return this.ripple;\n        });\n    }\n    createAdapter() {\n        return {};\n    }\n    update(changedProperties) {\n        const oldIndeterminate = changedProperties.get('indeterminate');\n        const oldChecked = changedProperties.get('checked');\n        const oldDisabled = changedProperties.get('disabled');\n        if (oldIndeterminate !== undefined || oldChecked !== undefined ||\n            oldDisabled !== undefined) {\n            const oldState = this.calculateAnimationStateName(!!oldChecked, !!oldIndeterminate, !!oldDisabled);\n            const newState = this.calculateAnimationStateName(this.checked, this.indeterminate, this.disabled);\n            this.animationClass = `${oldState}-${newState}`;\n        }\n        super.update(changedProperties);\n    }\n    calculateAnimationStateName(checked, indeterminate, disabled) {\n        if (disabled) {\n            return 'disabled';\n        }\n        else if (indeterminate) {\n            return 'indeterminate';\n        }\n        else if (checked) {\n            return 'checked';\n        }\n        else {\n            return 'unchecked';\n        }\n    }\n    // TODO(dfreedm): Make this use selected as a param after Polymer/internal#739\n    /** @soyTemplate */\n    renderRipple() {\n        return this.shouldRenderRipple ? this.renderRippleTemplate() : '';\n    }\n    /** @soyTemplate */\n    renderRippleTemplate() {\n        return html `<mwc-ripple\n        .disabled=\"${this.disabled}\"\n        unbounded></mwc-ripple>`;\n    }\n    /**\n     * @soyTemplate\n     * @soyAttributes checkboxAttributes: input\n     * @soyClasses checkboxClasses: .mdc-checkbox\n     */\n    render() {\n        const selected = this.indeterminate || this.checked;\n        /* eslint-disable eqeqeq */\n        // tslint:disable:triple-equals\n        /** @classMap */\n        const classes = {\n            'mdc-checkbox--disabled': this.disabled,\n            'mdc-checkbox--selected': selected,\n            'mdc-checkbox--touch': !this.reducedTouchTarget,\n            'mdc-ripple-upgraded--background-focused': this.focused,\n            // transition animiation classes\n            'mdc-checkbox--anim-checked-indeterminate': this.animationClass == 'checked-indeterminate',\n            'mdc-checkbox--anim-checked-unchecked': this.animationClass == 'checked-unchecked',\n            'mdc-checkbox--anim-indeterminate-checked': this.animationClass == 'indeterminate-checked',\n            'mdc-checkbox--anim-indeterminate-unchecked': this.animationClass == 'indeterminate-unchecked',\n            'mdc-checkbox--anim-unchecked-checked': this.animationClass == 'unchecked-checked',\n            'mdc-checkbox--anim-unchecked-indeterminate': this.animationClass == 'unchecked-indeterminate',\n        };\n        // tslint:enable:triple-equals\n        /* eslint-enable eqeqeq */\n        const ariaChecked = this.indeterminate ? 'mixed' : undefined;\n        return html `\n      <div class=\"mdc-checkbox mdc-checkbox--upgraded ${classMap(classes)}\">\n        <input type=\"checkbox\"\n              class=\"mdc-checkbox__native-control\"\n              name=\"${ifDefined(this.name)}\"\n              aria-checked=\"${ifDefined(ariaChecked)}\"\n              aria-label=\"${ifDefined(this.ariaLabel)}\"\n              aria-labelledby=\"${ifDefined(this.ariaLabelledBy)}\"\n              aria-describedby=\"${ifDefined(this.ariaDescribedBy)}\"\n              data-indeterminate=\"${this.indeterminate ? 'true' : 'false'}\"\n              ?disabled=\"${this.disabled}\"\n              .indeterminate=\"${this.indeterminate}\"\n              .checked=\"${this.checked}\"\n              .value=\"${this.value}\"\n              @change=\"${this.handleChange}\"\n              @focus=\"${this.handleFocus}\"\n              @blur=\"${this.handleBlur}\"\n              @mousedown=\"${this.handleRippleMouseDown}\"\n              @mouseenter=\"${this.handleRippleMouseEnter}\"\n              @mouseleave=\"${this.handleRippleMouseLeave}\"\n              @touchstart=\"${this.handleRippleTouchStart}\"\n              @touchend=\"${this.handleRippleDeactivate}\"\n              @touchcancel=\"${this.handleRippleDeactivate}\">\n        <div class=\"mdc-checkbox__background\"\n          @animationend=\"${this.resetAnimationClass}\">\n          <svg class=\"mdc-checkbox__checkmark\"\n              viewBox=\"0 0 24 24\">\n            <path class=\"mdc-checkbox__checkmark-path\"\n                  fill=\"none\"\n                  d=\"M1.73,12.91 8.1,19.28 22.79,4.59\"></path>\n          </svg>\n          <div class=\"mdc-checkbox__mixedmark\"></div>\n        </div>\n        ${this.renderRipple()}\n      </div>`;\n    }\n    setFormData(formData) {\n        if (this.name && this.checked) {\n            formData.append(this.name, this.value);\n        }\n    }\n    handleFocus() {\n        this.focused = true;\n        this.handleRippleFocus();\n    }\n    handleBlur() {\n        this.focused = false;\n        this.handleRippleBlur();\n    }\n    handleRippleMouseDown(event) {\n        const onUp = () => {\n            window.removeEventListener('mouseup', onUp);\n            this.handleRippleDeactivate();\n        };\n        window.addEventListener('mouseup', onUp);\n        this.rippleHandlers.startPress(event);\n    }\n    handleRippleTouchStart(event) {\n        this.rippleHandlers.startPress(event);\n    }\n    handleRippleDeactivate() {\n        this.rippleHandlers.endPress();\n    }\n    handleRippleMouseEnter() {\n        this.rippleHandlers.startHover();\n    }\n    handleRippleMouseLeave() {\n        this.rippleHandlers.endHover();\n    }\n    handleRippleFocus() {\n        this.rippleHandlers.startFocus();\n    }\n    handleRippleBlur() {\n        this.rippleHandlers.endFocus();\n    }\n    handleChange() {\n        this.checked = this.formElement.checked;\n        this.indeterminate = this.formElement.indeterminate;\n    }\n    resetAnimationClass() {\n        this.animationClass = '';\n    }\n    get isRippleActive() {\n        var _a;\n        return ((_a = this.rippleElement) === null || _a === void 0 ? void 0 : _a.isActive) || false;\n    }\n}\n__decorate([\n    query('.mdc-checkbox')\n], CheckboxBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('input')\n], CheckboxBase.prototype, \"formElement\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], CheckboxBase.prototype, \"checked\", void 0);\n__decorate([\n    property({ type: Boolean })\n], CheckboxBase.prototype, \"indeterminate\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], CheckboxBase.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], CheckboxBase.prototype, \"name\", void 0);\n__decorate([\n    property({ type: String })\n], CheckboxBase.prototype, \"value\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-label' })\n], CheckboxBase.prototype, \"ariaLabel\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-labelledby' })\n], CheckboxBase.prototype, \"ariaLabelledBy\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-describedby' })\n], CheckboxBase.prototype, \"ariaDescribedBy\", void 0);\n__decorate([\n    property({ type: Boolean })\n], CheckboxBase.prototype, \"reducedTouchTarget\", void 0);\n__decorate([\n    state()\n], CheckboxBase.prototype, \"animationClass\", void 0);\n__decorate([\n    state()\n], CheckboxBase.prototype, \"shouldRenderRipple\", void 0);\n__decorate([\n    state()\n], CheckboxBase.prototype, \"focused\", void 0);\n__decorate([\n    queryAsync('mwc-ripple')\n], CheckboxBase.prototype, \"ripple\", void 0);\n__decorate([\n    eventOptions({ passive: true })\n], CheckboxBase.prototype, \"handleRippleTouchStart\", null);\n//# sourceMappingURL=mwc-checkbox-base.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport { ariaProperty } from '@material/mwc-base/aria-property';\nimport { html, LitElement } from 'lit';\nimport { property } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { styleMap } from 'lit/directives/style-map.js';\n/** @soyCompatible */\nexport class CircularProgressBase extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.indeterminate = false;\n        this.progress = 0;\n        this.density = 0;\n        this.closed = false;\n    }\n    open() {\n        this.closed = false;\n    }\n    close() {\n        this.closed = true;\n    }\n    /**\n     * @soyTemplate\n     */\n    render() {\n        /** @classMap */\n        const classes = {\n            'mdc-circular-progress--closed': this.closed,\n            'mdc-circular-progress--indeterminate': this.indeterminate,\n        };\n        const containerSideLength = 48 + this.density * 4;\n        /** @styleMap */\n        const styles = {\n            'width': `${containerSideLength}px`,\n            'height': `${containerSideLength}px`,\n        };\n        return html `\n      <div\n        class=\"mdc-circular-progress ${classMap(classes)}\"\n        style=\"${styleMap(styles)}\"\n        role=\"progressbar\"\n        aria-label=\"${ifDefined(this.ariaLabel)}\"\n        aria-valuemin=\"0\"\n        aria-valuemax=\"1\"\n        aria-valuenow=\"${ifDefined(this.indeterminate ? undefined : this.progress)}\">\n        ${this.renderDeterminateContainer()}\n        ${this.renderIndeterminateContainer()}\n      </div>`;\n    }\n    /**\n     * @soyTemplate\n     */\n    renderDeterminateContainer() {\n        const sideLength = 48 + this.density * 4;\n        const center = sideLength / 2;\n        const circleRadius = this.density >= -3 ? 18 + this.density * 11 / 6 :\n            12.5 + (this.density + 3) * 5 / 4;\n        const circumference = 2 * 3.1415926 * circleRadius;\n        const determinateStrokeDashOffset = (1 - this.progress) * circumference;\n        const strokeWidth = this.density >= -3 ? 4 + this.density * (1 / 3) :\n            3 + (this.density + 3) * (1 / 6);\n        return html `\n      <div class=\"mdc-circular-progress__determinate-container\">\n        <svg class=\"mdc-circular-progress__determinate-circle-graphic\"\n             viewBox=\"0 0 ${sideLength} ${sideLength}\">\n          <circle class=\"mdc-circular-progress__determinate-track\"\n                  cx=\"${center}\" cy=\"${center}\" r=\"${circleRadius}\"\n                  stroke-width=\"${strokeWidth}\"></circle>\n          <circle class=\"mdc-circular-progress__determinate-circle\"\n                  cx=\"${center}\" cy=\"${center}\" r=\"${circleRadius}\"\n                  stroke-dasharray=\"${2 * 3.1415926 * circleRadius}\"\n                  stroke-dashoffset=\"${determinateStrokeDashOffset}\"\n                  stroke-width=\"${strokeWidth}\"></circle>\n        </svg>\n      </div>`;\n    }\n    /**\n     * @soyTemplate\n     */\n    renderIndeterminateContainer() {\n        return html `\n      <div class=\"mdc-circular-progress__indeterminate-container\">\n        <div class=\"mdc-circular-progress__spinner-layer\">\n          ${this.renderIndeterminateSpinnerLayer()}\n        </div>\n      </div>`;\n    }\n    /**\n     * @soyTemplate\n     */\n    renderIndeterminateSpinnerLayer() {\n        const sideLength = 48 + this.density * 4;\n        const center = sideLength / 2;\n        const circleRadius = this.density >= -3 ? 18 + this.density * 11 / 6 :\n            12.5 + (this.density + 3) * 5 / 4;\n        const circumference = 2 * 3.1415926 * circleRadius;\n        const halfCircumference = 0.5 * circumference;\n        const strokeWidth = this.density >= -3 ? 4 + this.density * (1 / 3) :\n            3 + (this.density + 3) * (1 / 6);\n        return html `\n        <div class=\"mdc-circular-progress__circle-clipper mdc-circular-progress__circle-left\">\n          <svg class=\"mdc-circular-progress__indeterminate-circle-graphic\"\n               viewBox=\"0 0 ${sideLength} ${sideLength}\">\n            <circle cx=\"${center}\" cy=\"${center}\" r=\"${circleRadius}\"\n                    stroke-dasharray=\"${circumference}\"\n                    stroke-dashoffset=\"${halfCircumference}\"\n                    stroke-width=\"${strokeWidth}\"></circle>\n          </svg>\n        </div>\n        <div class=\"mdc-circular-progress__gap-patch\">\n          <svg class=\"mdc-circular-progress__indeterminate-circle-graphic\"\n               viewBox=\"0 0 ${sideLength} ${sideLength}\">\n            <circle cx=\"${center}\" cy=\"${center}\" r=\"${circleRadius}\"\n                    stroke-dasharray=\"${circumference}\"\n                    stroke-dashoffset=\"${halfCircumference}\"\n                    stroke-width=\"${strokeWidth * 0.8}\"></circle>\n          </svg>\n        </div>\n        <div class=\"mdc-circular-progress__circle-clipper mdc-circular-progress__circle-right\">\n          <svg class=\"mdc-circular-progress__indeterminate-circle-graphic\"\n               viewBox=\"0 0 ${sideLength} ${sideLength}\">\n            <circle cx=\"${center}\" cy=\"${center}\" r=\"${circleRadius}\"\n                    stroke-dasharray=\"${circumference}\"\n                    stroke-dashoffset=\"${halfCircumference}\"\n                    stroke-width=\"${strokeWidth}\"></circle>\n          </svg>\n        </div>`;\n    }\n    update(changedProperties) {\n        super.update(changedProperties);\n        // Bound progress value in interval [0, 1].\n        if (changedProperties.has('progress')) {\n            if (this.progress > 1) {\n                this.progress = 1;\n            }\n            if (this.progress < 0) {\n                this.progress = 0;\n            }\n        }\n    }\n}\n__decorate([\n    property({ type: Boolean, reflect: true })\n], CircularProgressBase.prototype, \"indeterminate\", void 0);\n__decorate([\n    property({ type: Number, reflect: true })\n], CircularProgressBase.prototype, \"progress\", void 0);\n__decorate([\n    property({ type: Number, reflect: true })\n], CircularProgressBase.prototype, \"density\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], CircularProgressBase.prototype, \"closed\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-label' })\n], CircularProgressBase.prototype, \"ariaLabel\", void 0);\n//# sourceMappingURL=mwc-circular-progress-base.js.map","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport 'blocking-elements';\nimport 'wicg-inert';\nimport { cssClasses } from '@material/dialog/constants';\nimport MDCDialogFoundation from '@material/dialog/foundation';\nimport { applyPassive } from '@material/dom/events';\nimport { closest, matches } from '@material/dom/ponyfill';\nimport { addHasRemoveClass, BaseElement } from '@material/mwc-base/base-element';\nimport { observer } from '@material/mwc-base/observer';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nconst blockingElements = document.$blockingElements;\nexport class DialogBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.hideActions = false;\n        this.stacked = false;\n        this.heading = '';\n        this.scrimClickAction = 'close';\n        this.escapeKeyAction = 'close';\n        this.open = false;\n        this.defaultAction = 'close';\n        this.actionAttribute = 'dialogAction';\n        this.initialFocusAttribute = 'dialogInitialFocus';\n        this.initialSupressDefaultPressSelector = '';\n        this.mdcFoundationClass = MDCDialogFoundation;\n        this.boundHandleClick = null;\n        this.boundHandleKeydown = null;\n        this.boundHandleDocumentKeydown = null;\n    }\n    set suppressDefaultPressSelector(selector) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.setSuppressDefaultPressSelector(selector);\n        }\n        else {\n            this.initialSupressDefaultPressSelector = selector;\n        }\n    }\n    /**\n     * @export\n     */\n    get suppressDefaultPressSelector() {\n        return this.mdcFoundation ?\n            this.mdcFoundation.getSuppressDefaultPressSelector() :\n            this.initialSupressDefaultPressSelector;\n    }\n    get primaryButton() {\n        let assignedNodes = this.primarySlot.assignedNodes();\n        assignedNodes = assignedNodes.filter((node) => node instanceof HTMLElement);\n        const button = assignedNodes[0];\n        return button ? button : null;\n    }\n    emitNotification(name, action) {\n        const init = { detail: action ? { action } : {} };\n        const ev = new CustomEvent(name, init);\n        this.dispatchEvent(ev);\n    }\n    getInitialFocusEl() {\n        const initFocusSelector = `[${this.initialFocusAttribute}]`;\n        // only search light DOM. This typically handles all the cases\n        const lightDomQs = this.querySelector(initFocusSelector);\n        if (lightDomQs) {\n            return lightDomQs;\n        }\n        // if not in light dom, search each flattened distributed node.\n        const primarySlot = this.primarySlot;\n        const primaryNodes = primarySlot.assignedNodes({ flatten: true });\n        const primaryFocusElement = this.searchNodeTreesForAttribute(primaryNodes, this.initialFocusAttribute);\n        if (primaryFocusElement) {\n            return primaryFocusElement;\n        }\n        const secondarySlot = this.secondarySlot;\n        const secondaryNodes = secondarySlot.assignedNodes({ flatten: true });\n        const secondaryFocusElement = this.searchNodeTreesForAttribute(secondaryNodes, this.initialFocusAttribute);\n        if (secondaryFocusElement) {\n            return secondaryFocusElement;\n        }\n        const contentSlot = this.contentSlot;\n        const contentNodes = contentSlot.assignedNodes({ flatten: true });\n        const initFocusElement = this.searchNodeTreesForAttribute(contentNodes, this.initialFocusAttribute);\n        return initFocusElement;\n    }\n    searchNodeTreesForAttribute(nodes, attribute) {\n        for (const node of nodes) {\n            if (!(node instanceof HTMLElement)) {\n                continue;\n            }\n            if (node.hasAttribute(attribute)) {\n                return node;\n            }\n            else {\n                const selection = node.querySelector(`[${attribute}]`);\n                if (selection) {\n                    return selection;\n                }\n            }\n        }\n        return null;\n    }\n    createAdapter() {\n        return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { addBodyClass: () => document.body.style.overflow = 'hidden', removeBodyClass: () => document.body.style.overflow = '', areButtonsStacked: () => this.stacked, clickDefaultButton: () => {\n                const primary = this.primaryButton;\n                if (primary) {\n                    primary.click();\n                }\n            }, eventTargetMatches: (target, selector) => target ? matches(target, selector) : false, getActionFromEvent: (e) => {\n                if (!e.target) {\n                    return '';\n                }\n                const element = closest(e.target, `[${this.actionAttribute}]`);\n                const action = element && element.getAttribute(this.actionAttribute);\n                return action;\n            }, getInitialFocusEl: () => {\n                return this.getInitialFocusEl();\n            }, isContentScrollable: () => {\n                const el = this.contentElement;\n                return el ? el.scrollHeight > el.offsetHeight : false;\n            }, notifyClosed: (action) => this.emitNotification('closed', action), notifyClosing: (action) => {\n                if (!this.closingDueToDisconnect) {\n                    // Don't set our open state to closed just because we were\n                    // disconnected. That way if we get reconnected, we'll know to\n                    // re-open.\n                    this.open = false;\n                }\n                this.emitNotification('closing', action);\n            }, notifyOpened: () => this.emitNotification('opened'), notifyOpening: () => {\n                this.open = true;\n                this.emitNotification('opening');\n            }, reverseButtons: () => { }, releaseFocus: () => {\n                blockingElements.remove(this);\n            }, trapFocus: (el) => {\n                if (!this.isConnected) {\n                    // this is the case where it is opened and closed and then removed\n                    // from DOM before the animation has completed. Blocking Elements will\n                    // throw if this is the case\n                    return;\n                }\n                blockingElements.push(this);\n                if (el) {\n                    el.focus();\n                }\n            }, registerContentEventHandler: (evtType, handler) => {\n                const el = this.contentElement;\n                el.addEventListener(evtType, handler);\n            }, deregisterContentEventHandler: (evtType, handler) => {\n                const el = this.contentElement;\n                el.removeEventListener(evtType, handler);\n            }, isScrollableContentAtTop: () => {\n                const el = this.contentElement;\n                return el ? el.scrollTop === 0 : false;\n            }, isScrollableContentAtBottom: () => {\n                const el = this.contentElement;\n                return el ?\n                    Math.ceil(el.scrollHeight - el.scrollTop) === el.clientHeight :\n                    false;\n            }, registerWindowEventHandler: (evtType, handler) => {\n                window.addEventListener(evtType, handler, applyPassive());\n            }, deregisterWindowEventHandler: (evtType, handler) => {\n                window.removeEventListener(evtType, handler, applyPassive());\n            } });\n    }\n    render() {\n        const classes = {\n            [cssClasses.STACKED]: this.stacked,\n        };\n        let heading = html ``;\n        if (this.heading) {\n            heading = this.renderHeading();\n        }\n        const actionsClasses = {\n            'mdc-dialog__actions': !this.hideActions,\n        };\n        return html `\n    <div class=\"mdc-dialog ${classMap(classes)}\"\n        role=\"alertdialog\"\n        aria-modal=\"true\"\n        aria-labelledby=\"title\"\n        aria-describedby=\"content\">\n      <div class=\"mdc-dialog__container\">\n        <div class=\"mdc-dialog__surface\">\n          ${heading}\n          <div id=\"content\" class=\"mdc-dialog__content\">\n            <slot id=\"contentSlot\"></slot>\n          </div>\n          <footer\n              id=\"actions\"\n              class=\"${classMap(actionsClasses)}\">\n            <span>\n              <slot name=\"secondaryAction\"></slot>\n            </span>\n            <span>\n             <slot name=\"primaryAction\"></slot>\n            </span>\n          </footer>\n        </div>\n      </div>\n      <div class=\"mdc-dialog__scrim\"></div>\n    </div>`;\n    }\n    renderHeading() {\n        return html `\n      <h2 id=\"title\" class=\"mdc-dialog__title\">${this.heading}</h2>`;\n    }\n    firstUpdated() {\n        super.firstUpdated();\n        this.mdcFoundation.setAutoStackButtons(true);\n        if (this.initialSupressDefaultPressSelector) {\n            this.suppressDefaultPressSelector =\n                this.initialSupressDefaultPressSelector;\n        }\n        else {\n            this.suppressDefaultPressSelector = [\n                this.suppressDefaultPressSelector, 'mwc-textarea',\n                'mwc-menu mwc-list-item', 'mwc-select mwc-list-item'\n            ].join(', ');\n        }\n        this.boundHandleClick = this.mdcFoundation.handleClick.bind(this.mdcFoundation);\n        this.boundHandleKeydown = this.mdcFoundation.handleKeydown.bind(this.mdcFoundation);\n        this.boundHandleDocumentKeydown =\n            this.mdcFoundation.handleDocumentKeydown.bind(this.mdcFoundation);\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        if (this.open && this.mdcFoundation && !this.mdcFoundation.isOpen()) {\n            // We probably got disconnected while we were still open. Re-open,\n            // matching the behavior of native <dialog>.\n            this.setEventListeners();\n            this.mdcFoundation.open();\n        }\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        if (this.open && this.mdcFoundation) {\n            // If this dialog is opened and then disconnected, we want to close\n            // the foundation, so that 1) any pending timers are cancelled\n            // (in particular for trapFocus), and 2) if we reconnect, we can open\n            // the foundation again to retrigger animations and focus.\n            this.removeEventListeners();\n            this.closingDueToDisconnect = true;\n            this.mdcFoundation.close(this.currentAction || this.defaultAction);\n            this.closingDueToDisconnect = false;\n            this.currentAction = undefined;\n            // When we close normally, the releaseFocus callback handles removing\n            // ourselves from the blocking elements stack. However, that callback\n            // happens on a delay, and when we are closing due to a disconnect we\n            // need to remove ourselves before the blocking element polyfill's\n            // mutation observer notices and logs a warning, since it's not valid to\n            // be in the blocking elements stack while disconnected.\n            blockingElements.remove(this);\n        }\n    }\n    forceLayout() {\n        this.mdcFoundation.layout();\n    }\n    focus() {\n        const initialFocusEl = this.getInitialFocusEl();\n        initialFocusEl && initialFocusEl.focus();\n    }\n    blur() {\n        if (!this.shadowRoot) {\n            return;\n        }\n        const activeEl = this.shadowRoot.activeElement;\n        if (activeEl) {\n            if (activeEl instanceof HTMLElement) {\n                activeEl.blur();\n            }\n        }\n        else {\n            const root = this.getRootNode();\n            const activeEl = root instanceof Document ? root.activeElement : null;\n            if (activeEl instanceof HTMLElement) {\n                activeEl.blur();\n            }\n        }\n    }\n    setEventListeners() {\n        if (this.boundHandleClick) {\n            this.mdcRoot.addEventListener('click', this.boundHandleClick);\n        }\n        if (this.boundHandleKeydown) {\n            this.mdcRoot.addEventListener('keydown', this.boundHandleKeydown, applyPassive());\n        }\n        if (this.boundHandleDocumentKeydown) {\n            document.addEventListener('keydown', this.boundHandleDocumentKeydown, applyPassive());\n        }\n    }\n    removeEventListeners() {\n        if (this.boundHandleClick) {\n            this.mdcRoot.removeEventListener('click', this.boundHandleClick);\n        }\n        if (this.boundHandleKeydown) {\n            this.mdcRoot.removeEventListener('keydown', this.boundHandleKeydown);\n        }\n        if (this.boundHandleDocumentKeydown) {\n            document.removeEventListener('keydown', this.boundHandleDocumentKeydown);\n        }\n    }\n    close() {\n        this.open = false;\n    }\n    show() {\n        this.open = true;\n    }\n}\n__decorate([\n    query('.mdc-dialog')\n], DialogBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('slot[name=\"primaryAction\"]')\n], DialogBase.prototype, \"primarySlot\", void 0);\n__decorate([\n    query('slot[name=\"secondaryAction\"]')\n], DialogBase.prototype, \"secondarySlot\", void 0);\n__decorate([\n    query('#contentSlot')\n], DialogBase.prototype, \"contentSlot\", void 0);\n__decorate([\n    query('.mdc-dialog__content')\n], DialogBase.prototype, \"contentElement\", void 0);\n__decorate([\n    query('.mdc-container')\n], DialogBase.prototype, \"conatinerElement\", void 0);\n__decorate([\n    property({ type: Boolean })\n], DialogBase.prototype, \"hideActions\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function () {\n        this.forceLayout();\n    })\n], DialogBase.prototype, \"stacked\", void 0);\n__decorate([\n    property({ type: String })\n], DialogBase.prototype, \"heading\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (newAction) {\n        this.mdcFoundation.setScrimClickAction(newAction);\n    })\n], DialogBase.prototype, \"scrimClickAction\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (newAction) {\n        this.mdcFoundation.setEscapeKeyAction(newAction);\n    })\n], DialogBase.prototype, \"escapeKeyAction\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true }),\n    observer(function (isOpen) {\n        // Check isConnected because we could have been disconnected before first\n        // update. If we're now closed, then we shouldn't start the MDC foundation\n        // opening animation. If we're now closed, then we've already closed the\n        // foundation in disconnectedCallback.\n        if (this.mdcFoundation && this.isConnected) {\n            if (isOpen) {\n                this.setEventListeners();\n                this.mdcFoundation.open();\n            }\n            else {\n                this.removeEventListeners();\n                this.mdcFoundation.close(this.currentAction || this.defaultAction);\n                this.currentAction = undefined;\n            }\n        }\n    })\n], DialogBase.prototype, \"open\", void 0);\n__decorate([\n    property()\n], DialogBase.prototype, \"defaultAction\", void 0);\n__decorate([\n    property()\n], DialogBase.prototype, \"actionAttribute\", void 0);\n__decorate([\n    property()\n], DialogBase.prototype, \"initialFocusAttribute\", void 0);\n//# sourceMappingURL=mwc-dialog-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n// Note this blocking-elements import is not redundant with the one below,\n// because we need to ensure we import this module at runtime for its\n// side-effects. See\n// https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-imports-being-elided-in-my-emit.\nimport 'blocking-elements';\nimport 'wicg-inert';\nimport { strings } from '@material/drawer/constants';\nimport MDCDismissibleDrawerFoundation from '@material/drawer/dismissible/foundation';\nimport MDCModalDrawerFoundation from '@material/drawer/modal/foundation';\nimport { addHasRemoveClass, BaseElement } from '@material/mwc-base/base-element';\nimport { observer } from '@material/mwc-base/observer';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nconst blockingElements = document.$blockingElements;\nexport class DrawerBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this._previousFocus = null;\n        this.open = false;\n        this.hasHeader = false;\n        this.type = '';\n    }\n    get mdcFoundationClass() {\n        return this.type === 'modal' ? MDCModalDrawerFoundation :\n            MDCDismissibleDrawerFoundation;\n    }\n    createAdapter() {\n        return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { elementHasClass: (element, className) => element.classList.contains(className), saveFocus: () => {\n                // Note, casting to avoid cumbersome runtime check.\n                this._previousFocus =\n                    this.getRootNode().activeElement;\n            }, restoreFocus: () => {\n                const previousFocus = this._previousFocus && this._previousFocus.focus;\n                if (previousFocus) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    this._previousFocus.focus();\n                }\n            }, notifyClose: () => {\n                this.open = false;\n                this.dispatchEvent(new Event(strings.CLOSE_EVENT, { bubbles: true, cancelable: true }));\n            }, notifyOpen: () => {\n                this.open = true;\n                this.dispatchEvent(new Event(strings.OPEN_EVENT, { bubbles: true, cancelable: true }));\n            }, focusActiveNavigationItem: () => { }, trapFocus: () => {\n                blockingElements.push(this);\n                this.appContent.inert = true;\n            }, releaseFocus: () => {\n                blockingElements.remove(this);\n                this.appContent.inert = false;\n            } });\n    }\n    _handleScrimClick() {\n        if (this.mdcFoundation instanceof MDCModalDrawerFoundation) {\n            this.mdcFoundation.handleScrimClick();\n        }\n    }\n    render() {\n        const dismissible = this.type === 'dismissible' || this.type === 'modal';\n        const modal = this.type === 'modal';\n        const header = this.hasHeader ? html `\n      <div class=\"mdc-drawer__header\">\n        <h3 class=\"mdc-drawer__title\"><slot name=\"title\"></slot></h3>\n        <h6 class=\"mdc-drawer__subtitle\"><slot name=\"subtitle\"></slot></h6>\n        <slot name=\"header\"></slot>\n      </div>\n      ` :\n            '';\n        const classes = {\n            'mdc-drawer--dismissible': dismissible,\n            'mdc-drawer--modal': modal,\n        };\n        return html `\n      <aside class=\"mdc-drawer ${classMap(classes)}\">\n        ${header}\n        <div class=\"mdc-drawer__content\"><slot></slot></div>\n      </aside>\n      ${modal ? html `<div class=\"mdc-drawer-scrim\"\n                          @click=\"${this._handleScrimClick}\"></div>` :\n            ''}\n      <div class=\"mdc-drawer-app-content\">\n        <slot name=\"appContent\"></slot>\n      </div>\n      `;\n    }\n    // note, we avoid calling `super.firstUpdated()` to control when\n    // `createFoundation()` is called.\n    firstUpdated() {\n        this.mdcRoot.addEventListener('keydown', (e) => this.mdcFoundation.handleKeydown(e));\n        this.mdcRoot.addEventListener('transitionend', (e) => this.mdcFoundation.handleTransitionEnd(e));\n    }\n    updated(changedProperties) {\n        if (changedProperties.has('type')) {\n            this.createFoundation();\n        }\n    }\n}\n__decorate([\n    query('.mdc-drawer')\n], DrawerBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('.mdc-drawer-app-content')\n], DrawerBase.prototype, \"appContent\", void 0);\n__decorate([\n    observer(function (value) {\n        if (this.type === '') {\n            return;\n        }\n        if (value) {\n            this.mdcFoundation.open();\n        }\n        else {\n            this.mdcFoundation.close();\n        }\n    }),\n    property({ type: Boolean, reflect: true })\n], DrawerBase.prototype, \"open\", void 0);\n__decorate([\n    property({ type: Boolean })\n], DrawerBase.prototype, \"hasHeader\", void 0);\n__decorate([\n    property({ reflect: true })\n], DrawerBase.prototype, \"type\", void 0);\n//# sourceMappingURL=mwc-drawer-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport MDCFormFieldFoundation from '@material/form-field/foundation';\nimport { BaseElement } from '@material/mwc-base/base-element';\nimport { FormElement } from '@material/mwc-base/form-element';\nimport { observer } from '@material/mwc-base/observer';\nimport { html } from 'lit';\nimport { property, query, queryAssignedNodes } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nexport class FormfieldBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.alignEnd = false;\n        this.spaceBetween = false;\n        this.nowrap = false;\n        this.label = '';\n        this.mdcFoundationClass = MDCFormFieldFoundation;\n    }\n    createAdapter() {\n        return {\n            registerInteractionHandler: (type, handler) => {\n                this.labelEl.addEventListener(type, handler);\n            },\n            deregisterInteractionHandler: (type, handler) => {\n                this.labelEl.removeEventListener(type, handler);\n            },\n            activateInputRipple: async () => {\n                const input = this.input;\n                if (input instanceof FormElement) {\n                    const ripple = await input.ripple;\n                    if (ripple) {\n                        ripple.startPress();\n                    }\n                }\n            },\n            deactivateInputRipple: async () => {\n                const input = this.input;\n                if (input instanceof FormElement) {\n                    const ripple = await input.ripple;\n                    if (ripple) {\n                        ripple.endPress();\n                    }\n                }\n            },\n        };\n    }\n    get input() {\n        var _a, _b;\n        return (_b = (_a = this.slottedInputs) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n    }\n    render() {\n        const classes = {\n            'mdc-form-field--align-end': this.alignEnd,\n            'mdc-form-field--space-between': this.spaceBetween,\n            'mdc-form-field--nowrap': this.nowrap\n        };\n        return html `\n      <div class=\"mdc-form-field ${classMap(classes)}\">\n        <slot></slot>\n        <label class=\"mdc-label\"\n               @click=\"${this._labelClick}\">${this.label}</label>\n      </div>`;\n    }\n    click() {\n        this._labelClick();\n    }\n    _labelClick() {\n        const input = this.input;\n        if (input) {\n            input.focus();\n            input.click();\n        }\n    }\n}\n__decorate([\n    property({ type: Boolean })\n], FormfieldBase.prototype, \"alignEnd\", void 0);\n__decorate([\n    property({ type: Boolean })\n], FormfieldBase.prototype, \"spaceBetween\", void 0);\n__decorate([\n    property({ type: Boolean })\n], FormfieldBase.prototype, \"nowrap\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(async function (label) {\n        var _a;\n        (_a = this.input) === null || _a === void 0 ? void 0 : _a.setAttribute('aria-label', label);\n    })\n], FormfieldBase.prototype, \"label\", void 0);\n__decorate([\n    query('.mdc-form-field')\n], FormfieldBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    queryAssignedNodes('', true, '*')\n], FormfieldBase.prototype, \"slottedInputs\", void 0);\n__decorate([\n    query('label')\n], FormfieldBase.prototype, \"labelEl\", void 0);\n//# sourceMappingURL=mwc-formfield-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-ripple/mwc-ripple';\nimport { ariaProperty } from '@material/mwc-base/aria-property';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers';\nimport { html, LitElement } from 'lit';\nimport { eventOptions, property, query, queryAsync, state } from 'lit/decorators.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\n/** @soyCompatible */\nexport class IconButtonBase extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.disabled = false;\n        this.icon = '';\n        this.shouldRenderRipple = false;\n        this.rippleHandlers = new RippleHandlers(() => {\n            this.shouldRenderRipple = true;\n            return this.ripple;\n        });\n    }\n    /** @soyTemplate */\n    renderRipple() {\n        return this.shouldRenderRipple ? html `\n            <mwc-ripple\n                .disabled=\"${this.disabled}\"\n                unbounded>\n            </mwc-ripple>` :\n            '';\n    }\n    focus() {\n        const buttonElement = this.buttonElement;\n        if (buttonElement) {\n            this.rippleHandlers.startFocus();\n            buttonElement.focus();\n        }\n    }\n    blur() {\n        const buttonElement = this.buttonElement;\n        if (buttonElement) {\n            this.rippleHandlers.endFocus();\n            buttonElement.blur();\n        }\n    }\n    /** @soyTemplate */\n    render() {\n        return html `<button\n        class=\"mdc-icon-button mdc-icon-button--display-flex\"\n        aria-label=\"${this.ariaLabel || this.icon}\"\n        aria-haspopup=\"${ifDefined(this.ariaHasPopup)}\"\n        ?disabled=\"${this.disabled}\"\n        @focus=\"${this.handleRippleFocus}\"\n        @blur=\"${this.handleRippleBlur}\"\n        @mousedown=\"${this.handleRippleMouseDown}\"\n        @mouseenter=\"${this.handleRippleMouseEnter}\"\n        @mouseleave=\"${this.handleRippleMouseLeave}\"\n        @touchstart=\"${this.handleRippleTouchStart}\"\n        @touchend=\"${this.handleRippleDeactivate}\"\n        @touchcancel=\"${this.handleRippleDeactivate}\"\n    >${this.renderRipple()}\n    <i class=\"material-icons\">${this.icon}</i>\n    <span\n      ><slot></slot\n    ></span>\n  </button>`;\n    }\n    handleRippleMouseDown(event) {\n        const onUp = () => {\n            window.removeEventListener('mouseup', onUp);\n            this.handleRippleDeactivate();\n        };\n        window.addEventListener('mouseup', onUp);\n        this.rippleHandlers.startPress(event);\n    }\n    handleRippleTouchStart(event) {\n        this.rippleHandlers.startPress(event);\n    }\n    handleRippleDeactivate() {\n        this.rippleHandlers.endPress();\n    }\n    handleRippleMouseEnter() {\n        this.rippleHandlers.startHover();\n    }\n    handleRippleMouseLeave() {\n        this.rippleHandlers.endHover();\n    }\n    handleRippleFocus() {\n        this.rippleHandlers.startFocus();\n    }\n    handleRippleBlur() {\n        this.rippleHandlers.endFocus();\n    }\n}\n__decorate([\n    property({ type: Boolean, reflect: true })\n], IconButtonBase.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: String })\n], IconButtonBase.prototype, \"icon\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-label' })\n], IconButtonBase.prototype, \"ariaLabel\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-haspopup' })\n], IconButtonBase.prototype, \"ariaHasPopup\", void 0);\n__decorate([\n    query('button')\n], IconButtonBase.prototype, \"buttonElement\", void 0);\n__decorate([\n    queryAsync('mwc-ripple')\n], IconButtonBase.prototype, \"ripple\", void 0);\n__decorate([\n    state()\n], IconButtonBase.prototype, \"shouldRenderRipple\", void 0);\n__decorate([\n    eventOptions({ passive: true })\n], IconButtonBase.prototype, \"handleRippleMouseDown\", null);\n__decorate([\n    eventOptions({ passive: true })\n], IconButtonBase.prototype, \"handleRippleTouchStart\", null);\n//# sourceMappingURL=mwc-icon-button-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport { ariaProperty } from '@material/mwc-base/aria-property';\nimport { html, LitElement } from 'lit';\nimport { property, query, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { styleMap } from 'lit/directives/style-map.js';\n/** @soyCompatible */\nexport class LinearProgressBase extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.indeterminate = false;\n        this.progress = 0;\n        this.buffer = 1;\n        this.reverse = false;\n        this.closed = false;\n        this.stylePrimaryHalf = '';\n        this.stylePrimaryFull = '';\n        this.styleSecondaryQuarter = '';\n        this.styleSecondaryHalf = '';\n        this.styleSecondaryFull = '';\n        this.animationReady = true;\n        this.closedAnimationOff = false;\n        this.resizeObserver = null;\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        // if detached and reattached\n        if (this.rootEl) {\n            this.attachResizeObserver();\n        }\n    }\n    /**\n     * @soyTemplate\n     */\n    render() {\n        /** @classMap */\n        const classes = {\n            'mdc-linear-progress--closed': this.closed,\n            'mdc-linear-progress--closed-animation-off': this.closedAnimationOff,\n            'mdc-linear-progress--indeterminate': this.indeterminate,\n            // needed for controller-less render\n            'mdc-linear-progress--animation-ready': this.animationReady\n        };\n        /** @styleMap */\n        const rootStyles = {\n            '--mdc-linear-progress-primary-half': this.stylePrimaryHalf,\n            '--mdc-linear-progress-primary-half-neg': this.stylePrimaryHalf !== '' ? `-${this.stylePrimaryHalf}` : '',\n            '--mdc-linear-progress-primary-full': this.stylePrimaryFull,\n            '--mdc-linear-progress-primary-full-neg': this.stylePrimaryFull !== '' ? `-${this.stylePrimaryFull}` : '',\n            '--mdc-linear-progress-secondary-quarter': this.styleSecondaryQuarter,\n            '--mdc-linear-progress-secondary-quarter-neg': this.styleSecondaryQuarter !== '' ? `-${this.styleSecondaryQuarter}` :\n                '',\n            '--mdc-linear-progress-secondary-half': this.styleSecondaryHalf,\n            '--mdc-linear-progress-secondary-half-neg': this.styleSecondaryHalf !== '' ? `-${this.styleSecondaryHalf}` : '',\n            '--mdc-linear-progress-secondary-full': this.styleSecondaryFull,\n            '--mdc-linear-progress-secondary-full-neg': this.styleSecondaryFull !== '' ? `-${this.styleSecondaryFull}` : '',\n        };\n        /** @styleMap */\n        const bufferBarStyles = {\n            'flex-basis': this.indeterminate ? '100%' : `${this.buffer * 100}%`,\n        };\n        /** @styleMap */\n        const primaryBarStyles = {\n            transform: this.indeterminate ? 'scaleX(1)' : `scaleX(${this.progress})`,\n        };\n        return html `\n      <div\n          role=\"progressbar\"\n          class=\"mdc-linear-progress ${classMap(classes)}\"\n          style=\"${styleMap(rootStyles)}\"\n          dir=\"${ifDefined(this.reverse ? 'rtl' : undefined)}\"\n          aria-label=\"${ifDefined(this.ariaLabel)}\"\n          aria-valuemin=\"0\"\n          aria-valuemax=\"1\"\n          aria-valuenow=\"${ifDefined(this.indeterminate ? undefined : this.progress)}\"\n        @transitionend=\"${this.syncClosedState}\">\n        <div class=\"mdc-linear-progress__buffer\">\n          <div\n            class=\"mdc-linear-progress__buffer-bar\"\n            style=${styleMap(bufferBarStyles)}>\n          </div>\n          <div class=\"mdc-linear-progress__buffer-dots\"></div>\n        </div>\n        <div\n            class=\"mdc-linear-progress__bar mdc-linear-progress__primary-bar\"\n            style=${styleMap(primaryBarStyles)}>\n          <span class=\"mdc-linear-progress__bar-inner\"></span>\n        </div>\n        <div class=\"mdc-linear-progress__bar mdc-linear-progress__secondary-bar\">\n          <span class=\"mdc-linear-progress__bar-inner\"></span>\n        </div>\n      </div>`;\n    }\n    update(changedProperties) {\n        // - When showing the indicator, enable animations immediately.\n        // - On first render, disable the animation immediately.\n        // - For normal calls to hide the component, let transitionend event trigger\n        //   disabling of animations instead (see render method), so that animation\n        //   does not jump in the middle of fade out.\n        if (changedProperties.has('closed') &&\n            (!this.closed || changedProperties.get('closed') === undefined)) {\n            this.syncClosedState();\n        }\n        super.update(changedProperties);\n    }\n    async firstUpdated(changed) {\n        super.firstUpdated(changed);\n        this.attachResizeObserver();\n    }\n    syncClosedState() {\n        this.closedAnimationOff = this.closed;\n    }\n    updated(changed) {\n        // restart animation for timing if reverse changed and is indeterminate.\n        // don't restart here if indeterminate has changed as well because we don't\n        // want to incur an extra style recalculation\n        if (!changed.has('indeterminate') && changed.has('reverse') &&\n            this.indeterminate) {\n            this.restartAnimation();\n        }\n        // Recaclulate the animation css custom props and restart the calculation\n        // if this is not the first render cycle, otherwise, resize observer init\n        // will already handle this and prevent unnecessary rerender + style recalc\n        // but resize observer will not update animation vals while determinate\n        if (changed.has('indeterminate') &&\n            changed.get('indeterminate') !== undefined && this.indeterminate &&\n            window.ResizeObserver) {\n            this.calculateAndSetAnimationDimensions(this.rootEl.offsetWidth);\n        }\n        super.updated(changed);\n    }\n    disconnectedCallback() {\n        if (this.resizeObserver) {\n            this.resizeObserver.disconnect();\n            this.resizeObserver = null;\n        }\n        super.disconnectedCallback();\n    }\n    attachResizeObserver() {\n        if (window.ResizeObserver) {\n            this.resizeObserver =\n                new window\n                    .ResizeObserver((entries) => {\n                    if (!this.indeterminate) {\n                        return;\n                    }\n                    for (const entry of entries) {\n                        if (entry.contentRect) {\n                            const width = entry.contentRect.width;\n                            this.calculateAndSetAnimationDimensions(width);\n                        }\n                    }\n                });\n            this.resizeObserver.observe(this.rootEl);\n            return;\n        }\n        this.resizeObserver = null;\n    }\n    calculateAndSetAnimationDimensions(width) {\n        const primaryHalf = width * 0.8367142;\n        const primaryFull = width * 2.00611057;\n        const secondaryQuarter = width * 0.37651913;\n        const secondaryHalf = width * 0.84386165;\n        const secondaryFull = width * 1.60277782;\n        this.stylePrimaryHalf = `${primaryHalf}px`;\n        this.stylePrimaryFull = `${primaryFull}px`;\n        this.styleSecondaryQuarter = `${secondaryQuarter}px`;\n        this.styleSecondaryHalf = `${secondaryHalf}px`;\n        this.styleSecondaryFull = `${secondaryFull}px`;\n        // need to restart animation for custom props to apply to keyframes\n        this.restartAnimation();\n    }\n    async restartAnimation() {\n        this.animationReady = false;\n        await this.updateComplete;\n        await new Promise(requestAnimationFrame);\n        this.animationReady = true;\n        await this.updateComplete;\n    }\n    open() {\n        this.closed = false;\n    }\n    close() {\n        this.closed = true;\n    }\n}\n__decorate([\n    query('.mdc-linear-progress')\n], LinearProgressBase.prototype, \"rootEl\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], LinearProgressBase.prototype, \"indeterminate\", void 0);\n__decorate([\n    property({ type: Number })\n], LinearProgressBase.prototype, \"progress\", void 0);\n__decorate([\n    property({ type: Number })\n], LinearProgressBase.prototype, \"buffer\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], LinearProgressBase.prototype, \"reverse\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], LinearProgressBase.prototype, \"closed\", void 0);\n__decorate([\n    ariaProperty,\n    property({ attribute: 'aria-label' })\n], LinearProgressBase.prototype, \"ariaLabel\", void 0);\n__decorate([\n    state()\n], LinearProgressBase.prototype, \"stylePrimaryHalf\", void 0);\n__decorate([\n    state()\n], LinearProgressBase.prototype, \"stylePrimaryFull\", void 0);\n__decorate([\n    state()\n], LinearProgressBase.prototype, \"styleSecondaryQuarter\", void 0);\n__decorate([\n    state()\n], LinearProgressBase.prototype, \"styleSecondaryHalf\", void 0);\n__decorate([\n    state()\n], LinearProgressBase.prototype, \"styleSecondaryFull\", void 0);\n__decorate([\n    state()\n], LinearProgressBase.prototype, \"animationReady\", void 0);\n__decorate([\n    state()\n], LinearProgressBase.prototype, \"closedAnimationOff\", void 0);\n//# sourceMappingURL=mwc-linear-progress-base.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-checkbox';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ListItemBase } from './mwc-list-item-base';\nexport class CheckListItemBase extends ListItemBase {\n    constructor() {\n        super(...arguments);\n        this.left = false;\n        this.graphic = 'control';\n    }\n    render() {\n        const checkboxClasses = {\n            'mdc-deprecated-list-item__graphic': this.left,\n            'mdc-deprecated-list-item__meta': !this.left,\n        };\n        const text = this.renderText();\n        const graphic = this.graphic && this.graphic !== 'control' && !this.left ?\n            this.renderGraphic() :\n            html ``;\n        const meta = this.hasMeta && this.left ? this.renderMeta() : html ``;\n        const ripple = this.renderRipple();\n        return html `\n      ${ripple}\n      ${graphic}\n      ${this.left ? '' : text}\n      <span class=${classMap(checkboxClasses)}>\n        <mwc-checkbox\n            reducedTouchTarget\n            tabindex=${this.tabindex}\n            .checked=${this.selected}\n            ?disabled=${this.disabled}\n            @change=${this.onChange}>\n        </mwc-checkbox>\n      </span>\n      ${this.left ? text : ''}\n      ${meta}`;\n    }\n    async onChange(evt) {\n        const checkbox = evt.target;\n        const changeFromProp = this.selected === checkbox.checked;\n        if (!changeFromProp) {\n            this._skipPropRequest = true;\n            this.selected = checkbox.checked;\n            await this.updateComplete;\n            this._skipPropRequest = false;\n        }\n    }\n}\n__decorate([\n    query('slot')\n], CheckListItemBase.prototype, \"slotElement\", void 0);\n__decorate([\n    query('mwc-checkbox')\n], CheckListItemBase.prototype, \"checkboxElement\", void 0);\n__decorate([\n    property({ type: Boolean })\n], CheckListItemBase.prototype, \"left\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], CheckListItemBase.prototype, \"graphic\", void 0);\n//# sourceMappingURL=mwc-check-list-item-base.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport './mwc-list-item';\nimport { BaseElement } from '@material/mwc-base/base-element';\nimport { observer } from '@material/mwc-base/observer';\nimport { deepActiveElementPath, doesElementContainFocus, isNodeElement } from '@material/mwc-base/utils';\nimport { html } from 'lit';\nimport { property, query, queryAssignedNodes } from 'lit/decorators.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport MDCListFoundation, { isIndexSet } from './mwc-list-foundation';\nexport { createSetFromIndex, isEventMulti, isIndexSet } from './mwc-list-foundation';\nfunction debounceLayout(callback, waitInMS = 50) {\n    let timeoutId;\n    // tslint:disable-next-line\n    return function (updateItems = true) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => {\n            callback(updateItems);\n        }, waitInMS);\n    };\n}\nconst isListItem = (element) => {\n    return element.hasAttribute('mwc-list-item');\n};\nfunction clearAndCreateItemsReadyPromise() {\n    const oldResolver = this.itemsReadyResolver;\n    this.itemsReady = new Promise((res) => {\n        // TODO(b/175626389): Type '(value: never[] | PromiseLike<never[]>) => void'\n        // is not assignable to type '(value?: never[] | PromiseLike<never[]> |\n        // undefined) => void'.\n        return this.itemsReadyResolver = res;\n    });\n    oldResolver();\n}\n/**\n * @fires selected {SelectedDetail}\n * @fires action {ActionDetail}\n * @fires items-updated\n */\nexport class ListBase extends BaseElement {\n    constructor() {\n        super();\n        this.mdcAdapter = null;\n        this.mdcFoundationClass = MDCListFoundation;\n        this.activatable = false;\n        this.multi = false;\n        this.wrapFocus = false;\n        this.itemRoles = null;\n        this.innerRole = null;\n        this.innerAriaLabel = null;\n        this.rootTabbable = false;\n        this.previousTabindex = null;\n        this.noninteractive = false;\n        this.itemsReadyResolver = (() => {\n            //\n        });\n        this.itemsReady = Promise.resolve([]);\n        // tslint:enable:ban-ts-ignore\n        this.items_ = [];\n        const debouncedFunction = debounceLayout(this.layout.bind(this));\n        this.debouncedLayout = (updateItems = true) => {\n            clearAndCreateItemsReadyPromise.call(this);\n            debouncedFunction(updateItems);\n        };\n    }\n    // tslint:disable:ban-ts-ignore\n    async getUpdateComplete() {\n        // @ts-ignore\n        const result = await super.getUpdateComplete();\n        await this.itemsReady;\n        return result;\n    }\n    get items() {\n        return this.items_;\n    }\n    updateItems() {\n        var _a;\n        const nodes = (_a = this.assignedElements) !== null && _a !== void 0 ? _a : [];\n        const listItems = [];\n        for (const node of nodes) {\n            if (isListItem(node)) {\n                listItems.push(node);\n                node._managingList = this;\n            }\n            if (node.hasAttribute('divider') && !node.hasAttribute('role')) {\n                node.setAttribute('role', 'separator');\n            }\n        }\n        this.items_ = listItems;\n        const selectedIndices = new Set();\n        this.items_.forEach((item, index) => {\n            if (this.itemRoles) {\n                item.setAttribute('role', this.itemRoles);\n            }\n            else {\n                item.removeAttribute('role');\n            }\n            if (item.selected) {\n                selectedIndices.add(index);\n            }\n        });\n        if (this.multi) {\n            this.select(selectedIndices);\n        }\n        else {\n            const index = selectedIndices.size ? selectedIndices.entries().next().value[1] : -1;\n            this.select(index);\n        }\n        const itemsUpdatedEv = new Event('items-updated', { bubbles: true, composed: true });\n        this.dispatchEvent(itemsUpdatedEv);\n    }\n    get selected() {\n        const index = this.index;\n        if (!isIndexSet(index)) {\n            if (index === -1) {\n                return null;\n            }\n            return this.items[index];\n        }\n        const selected = [];\n        for (const entry of index) {\n            selected.push(this.items[entry]);\n        }\n        return selected;\n    }\n    get index() {\n        if (this.mdcFoundation) {\n            return this.mdcFoundation.getSelectedIndex();\n        }\n        return -1;\n    }\n    render() {\n        const role = this.innerRole === null ? undefined : this.innerRole;\n        const ariaLabel = this.innerAriaLabel === null ? undefined : this.innerAriaLabel;\n        const tabindex = this.rootTabbable ? '0' : '-1';\n        return html `\n      <!-- @ts-ignore -->\n      <ul\n          tabindex=${tabindex}\n          role=\"${ifDefined(role)}\"\n          aria-label=\"${ifDefined(ariaLabel)}\"\n          class=\"mdc-deprecated-list\"\n          @keydown=${this.onKeydown}\n          @focusin=${this.onFocusIn}\n          @focusout=${this.onFocusOut}\n          @request-selected=${this.onRequestSelected}\n          @list-item-rendered=${this.onListItemConnected}>\n        <slot></slot>\n        ${this.renderPlaceholder()}\n      </ul>\n    `;\n    }\n    renderPlaceholder() {\n        var _a;\n        const nodes = (_a = this.assignedElements) !== null && _a !== void 0 ? _a : [];\n        if (this.emptyMessage !== undefined && nodes.length === 0) {\n            return html `\n        <mwc-list-item noninteractive>${this.emptyMessage}</mwc-list-item>\n      `;\n        }\n        return null;\n    }\n    firstUpdated() {\n        super.firstUpdated();\n        if (!this.items.length) {\n            // required because this is called before observers\n            this.mdcFoundation.setMulti(this.multi);\n            // for when children upgrade before list\n            this.layout();\n        }\n    }\n    onFocusIn(evt) {\n        if (this.mdcFoundation && this.mdcRoot) {\n            const index = this.getIndexOfTarget(evt);\n            this.mdcFoundation.handleFocusIn(evt, index);\n        }\n    }\n    onFocusOut(evt) {\n        if (this.mdcFoundation && this.mdcRoot) {\n            const index = this.getIndexOfTarget(evt);\n            this.mdcFoundation.handleFocusOut(evt, index);\n        }\n    }\n    onKeydown(evt) {\n        if (this.mdcFoundation && this.mdcRoot) {\n            const index = this.getIndexOfTarget(evt);\n            const target = evt.target;\n            const isRootListItem = isListItem(target);\n            this.mdcFoundation.handleKeydown(evt, isRootListItem, index);\n        }\n    }\n    onRequestSelected(evt) {\n        if (this.mdcFoundation) {\n            let index = this.getIndexOfTarget(evt);\n            // might happen in shady dom slowness. Recalc children\n            if (index === -1) {\n                this.layout();\n                index = this.getIndexOfTarget(evt);\n                // still not found; may not be mwc-list-item. Unsupported case.\n                if (index === -1) {\n                    return;\n                }\n            }\n            const element = this.items[index];\n            if (element.disabled) {\n                return;\n            }\n            const selected = evt.detail.selected;\n            const source = evt.detail.source;\n            this.mdcFoundation.handleSingleSelection(index, source === 'interaction', selected);\n            evt.stopPropagation();\n        }\n    }\n    getIndexOfTarget(evt) {\n        const elements = this.items;\n        const path = evt.composedPath();\n        for (const pathItem of path) {\n            let index = -1;\n            if (isNodeElement(pathItem) && isListItem(pathItem)) {\n                index = elements.indexOf(pathItem);\n            }\n            if (index !== -1) {\n                return index;\n            }\n        }\n        return -1;\n    }\n    createAdapter() {\n        this.mdcAdapter = {\n            getListItemCount: () => {\n                if (this.mdcRoot) {\n                    return this.items.length;\n                }\n                return 0;\n            },\n            getFocusedElementIndex: this.getFocusedItemIndex,\n            getAttributeForElementIndex: (index, attr) => {\n                const listElement = this.mdcRoot;\n                if (!listElement) {\n                    return '';\n                }\n                const element = this.items[index];\n                return element ? element.getAttribute(attr) : '';\n            },\n            setAttributeForElementIndex: (index, attr, val) => {\n                if (!this.mdcRoot) {\n                    return;\n                }\n                const element = this.items[index];\n                if (element) {\n                    element.setAttribute(attr, val);\n                }\n            },\n            focusItemAtIndex: (index) => {\n                const element = this.items[index];\n                if (element) {\n                    element.focus();\n                }\n            },\n            setTabIndexForElementIndex: (index, value) => {\n                const item = this.items[index];\n                if (item) {\n                    item.tabindex = value;\n                }\n            },\n            notifyAction: (index) => {\n                const init = { bubbles: true, composed: true };\n                init.detail = { index };\n                const ev = new CustomEvent('action', init);\n                this.dispatchEvent(ev);\n            },\n            notifySelected: (index, diff) => {\n                const init = { bubbles: true, composed: true };\n                init.detail = { index, diff };\n                const ev = new CustomEvent('selected', init);\n                this.dispatchEvent(ev);\n            },\n            isFocusInsideList: () => {\n                return doesElementContainFocus(this);\n            },\n            isRootFocused: () => {\n                const mdcRoot = this.mdcRoot;\n                const root = mdcRoot.getRootNode();\n                return root.activeElement === mdcRoot;\n            },\n            setDisabledStateForElementIndex: (index, value) => {\n                const item = this.items[index];\n                if (!item) {\n                    return;\n                }\n                item.disabled = value;\n            },\n            getDisabledStateForElementIndex: (index) => {\n                const item = this.items[index];\n                if (!item) {\n                    return false;\n                }\n                return item.disabled;\n            },\n            setSelectedStateForElementIndex: (index, value) => {\n                const item = this.items[index];\n                if (!item) {\n                    return;\n                }\n                item.selected = value;\n            },\n            getSelectedStateForElementIndex: (index) => {\n                const item = this.items[index];\n                if (!item) {\n                    return false;\n                }\n                return item.selected;\n            },\n            setActivatedStateForElementIndex: (index, value) => {\n                const item = this.items[index];\n                if (!item) {\n                    return;\n                }\n                item.activated = value;\n            },\n        };\n        return this.mdcAdapter;\n    }\n    selectUi(index, activate = false) {\n        const item = this.items[index];\n        if (item) {\n            item.selected = true;\n            item.activated = activate;\n        }\n    }\n    deselectUi(index) {\n        const item = this.items[index];\n        if (item) {\n            item.selected = false;\n            item.activated = false;\n        }\n    }\n    select(index) {\n        if (!this.mdcFoundation) {\n            return;\n        }\n        this.mdcFoundation.setSelectedIndex(index);\n    }\n    toggle(index, force) {\n        if (this.multi) {\n            this.mdcFoundation.toggleMultiAtIndex(index, force);\n        }\n    }\n    onListItemConnected(e) {\n        const target = e.target;\n        this.layout(this.items.indexOf(target) === -1);\n    }\n    layout(updateItems = true) {\n        if (updateItems) {\n            this.updateItems();\n        }\n        const first = this.items[0];\n        for (const item of this.items) {\n            item.tabindex = -1;\n        }\n        if (first) {\n            if (this.noninteractive) {\n                if (!this.previousTabindex) {\n                    this.previousTabindex = first;\n                }\n            }\n            else {\n                first.tabindex = 0;\n            }\n        }\n        this.itemsReadyResolver();\n    }\n    getFocusedItemIndex() {\n        if (!this.mdcRoot) {\n            return -1;\n        }\n        if (!this.items.length) {\n            return -1;\n        }\n        const activeElementPath = deepActiveElementPath();\n        if (!activeElementPath.length) {\n            return -1;\n        }\n        for (let i = activeElementPath.length - 1; i >= 0; i--) {\n            const activeItem = activeElementPath[i];\n            if (isListItem(activeItem)) {\n                return this.items.indexOf(activeItem);\n            }\n        }\n        return -1;\n    }\n    focusItemAtIndex(index) {\n        for (const item of this.items) {\n            if (item.tabindex === 0) {\n                item.tabindex = -1;\n                break;\n            }\n        }\n        this.items[index].tabindex = 0;\n        this.items[index].focus();\n    }\n    focus() {\n        const root = this.mdcRoot;\n        if (root) {\n            root.focus();\n        }\n    }\n    blur() {\n        const root = this.mdcRoot;\n        if (root) {\n            root.blur();\n        }\n    }\n}\n__decorate([\n    property({ type: String })\n], ListBase.prototype, \"emptyMessage\", void 0);\n__decorate([\n    query('.mdc-deprecated-list')\n], ListBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    queryAssignedNodes('', true, '*')\n], ListBase.prototype, \"assignedElements\", void 0);\n__decorate([\n    queryAssignedNodes('', true, '[tabindex=\"0\"]')\n], ListBase.prototype, \"tabbableElements\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.setUseActivatedClass(value);\n        }\n    })\n], ListBase.prototype, \"activatable\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (newValue, oldValue) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.setMulti(newValue);\n        }\n        if (oldValue !== undefined) {\n            this.layout();\n        }\n    })\n], ListBase.prototype, \"multi\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.setWrapFocus(value);\n        }\n    })\n], ListBase.prototype, \"wrapFocus\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (_newValue, oldValue) {\n        if (oldValue !== undefined) {\n            this.updateItems();\n        }\n    })\n], ListBase.prototype, \"itemRoles\", void 0);\n__decorate([\n    property({ type: String })\n], ListBase.prototype, \"innerRole\", void 0);\n__decorate([\n    property({ type: String })\n], ListBase.prototype, \"innerAriaLabel\", void 0);\n__decorate([\n    property({ type: Boolean })\n], ListBase.prototype, \"rootTabbable\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true }),\n    observer(function (value) {\n        var _a, _b;\n        if (value) {\n            const tabbable = (_b = (_a = this.tabbableElements) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n            this.previousTabindex = tabbable;\n            if (tabbable) {\n                tabbable.setAttribute('tabindex', '-1');\n            }\n        }\n        else if (!value && this.previousTabindex) {\n            this.previousTabindex.setAttribute('tabindex', '0');\n            this.previousTabindex = null;\n        }\n    })\n], ListBase.prototype, \"noninteractive\", void 0);\n//# sourceMappingURL=mwc-list-base.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-ripple/mwc-ripple';\nimport { observer } from '@material/mwc-base/observer';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers';\nimport { html, LitElement } from 'lit';\nimport { property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\n/**\n * @fires request-selected {RequestSelectedDetail}\n * @fires list-item-rendered\n */\nexport class ListItemBase extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.value = '';\n        this.group = null;\n        this.tabindex = -1;\n        this.disabled = false;\n        this.twoline = false;\n        this.activated = false;\n        this.graphic = null;\n        this.multipleGraphics = false;\n        this.hasMeta = false;\n        this.noninteractive = false;\n        this.selected = false;\n        this.shouldRenderRipple = false;\n        this._managingList = null;\n        this.boundOnClick = this.onClick.bind(this);\n        this._firstChanged = true;\n        this._skipPropRequest = false;\n        this.rippleHandlers = new RippleHandlers(() => {\n            this.shouldRenderRipple = true;\n            return this.ripple;\n        });\n        this.listeners = [\n            {\n                target: this,\n                eventNames: ['click'],\n                cb: () => {\n                    this.onClick();\n                },\n            },\n            {\n                target: this,\n                eventNames: ['mouseenter'],\n                cb: this.rippleHandlers.startHover,\n            },\n            {\n                target: this,\n                eventNames: ['mouseleave'],\n                cb: this.rippleHandlers.endHover,\n            },\n            {\n                target: this,\n                eventNames: ['focus'],\n                cb: this.rippleHandlers.startFocus,\n            },\n            {\n                target: this,\n                eventNames: ['blur'],\n                cb: this.rippleHandlers.endFocus,\n            },\n            {\n                target: this,\n                eventNames: ['mousedown', 'touchstart'],\n                cb: (e) => {\n                    const name = e.type;\n                    this.onDown(name === 'mousedown' ? 'mouseup' : 'touchend', e);\n                },\n            },\n        ];\n    }\n    get text() {\n        const textContent = this.textContent;\n        return textContent ? textContent.trim() : '';\n    }\n    render() {\n        const text = this.renderText();\n        const graphic = this.graphic ? this.renderGraphic() : html ``;\n        const meta = this.hasMeta ? this.renderMeta() : html ``;\n        return html `\n      ${this.renderRipple()}\n      ${graphic}\n      ${text}\n      ${meta}`;\n    }\n    renderRipple() {\n        if (this.shouldRenderRipple) {\n            return html `\n      <mwc-ripple\n        .activated=${this.activated}>\n      </mwc-ripple>`;\n        }\n        else if (this.activated) {\n            return html `<div class=\"fake-activated-ripple\"></div>`;\n        }\n        else {\n            return '';\n        }\n    }\n    renderGraphic() {\n        const graphicClasses = {\n            multi: this.multipleGraphics,\n        };\n        return html `\n      <span class=\"mdc-deprecated-list-item__graphic material-icons ${classMap(graphicClasses)}\">\n        <slot name=\"graphic\"></slot>\n      </span>`;\n    }\n    renderMeta() {\n        return html `\n      <span class=\"mdc-deprecated-list-item__meta material-icons\">\n        <slot name=\"meta\"></slot>\n      </span>`;\n    }\n    renderText() {\n        const inner = this.twoline ? this.renderTwoline() : this.renderSingleLine();\n        return html `\n      <span class=\"mdc-deprecated-list-item__text\">\n        ${inner}\n      </span>`;\n    }\n    renderSingleLine() {\n        return html `<slot></slot>`;\n    }\n    renderTwoline() {\n        return html `\n      <span class=\"mdc-deprecated-list-item__primary-text\">\n        <slot></slot>\n      </span>\n      <span class=\"mdc-deprecated-list-item__secondary-text\">\n        <slot name=\"secondary\"></slot>\n      </span>\n    `;\n    }\n    onClick() {\n        this.fireRequestSelected(!this.selected, 'interaction');\n    }\n    onDown(upName, evt) {\n        const onUp = () => {\n            window.removeEventListener(upName, onUp);\n            this.rippleHandlers.endPress();\n        };\n        window.addEventListener(upName, onUp);\n        this.rippleHandlers.startPress(evt);\n    }\n    fireRequestSelected(selected, source) {\n        if (this.noninteractive) {\n            return;\n        }\n        const customEv = new CustomEvent('request-selected', { bubbles: true, composed: true, detail: { source, selected } });\n        this.dispatchEvent(customEv);\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        if (!this.noninteractive) {\n            this.setAttribute('mwc-list-item', '');\n        }\n        for (const listener of this.listeners) {\n            for (const eventName of listener.eventNames) {\n                listener.target.addEventListener(eventName, listener.cb, { passive: true });\n            }\n        }\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        for (const listener of this.listeners) {\n            for (const eventName of listener.eventNames) {\n                listener.target.removeEventListener(eventName, listener.cb);\n            }\n        }\n        if (this._managingList) {\n            this._managingList.debouncedLayout ?\n                this._managingList.debouncedLayout(true) :\n                this._managingList.layout(true);\n        }\n    }\n    // composed flag, event fire through shadow root and up through composed tree\n    firstUpdated() {\n        const ev = new Event('list-item-rendered', { bubbles: true, composed: true });\n        this.dispatchEvent(ev);\n    }\n}\n__decorate([\n    query('slot')\n], ListItemBase.prototype, \"slotElement\", void 0);\n__decorate([\n    queryAsync('mwc-ripple')\n], ListItemBase.prototype, \"ripple\", void 0);\n__decorate([\n    property({ type: String })\n], ListItemBase.prototype, \"value\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], ListItemBase.prototype, \"group\", void 0);\n__decorate([\n    property({ type: Number, reflect: true })\n], ListItemBase.prototype, \"tabindex\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true }),\n    observer(function (value) {\n        if (value) {\n            this.setAttribute('aria-disabled', 'true');\n        }\n        else {\n            this.setAttribute('aria-disabled', 'false');\n        }\n    })\n], ListItemBase.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], ListItemBase.prototype, \"twoline\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], ListItemBase.prototype, \"activated\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], ListItemBase.prototype, \"graphic\", void 0);\n__decorate([\n    property({ type: Boolean })\n], ListItemBase.prototype, \"multipleGraphics\", void 0);\n__decorate([\n    property({ type: Boolean })\n], ListItemBase.prototype, \"hasMeta\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true }),\n    observer(function (value) {\n        if (value) {\n            this.removeAttribute('aria-checked');\n            this.removeAttribute('mwc-list-item');\n            this.selected = false;\n            this.activated = false;\n            this.tabIndex = -1;\n        }\n        else {\n            this.setAttribute('mwc-list-item', '');\n        }\n    })\n], ListItemBase.prototype, \"noninteractive\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true }),\n    observer(function (value) {\n        const role = this.getAttribute('role');\n        const isAriaSelectable = role === 'gridcell' || role === 'option' ||\n            role === 'row' || role === 'tab';\n        if (isAriaSelectable && value) {\n            this.setAttribute('aria-selected', 'true');\n        }\n        else if (isAriaSelectable) {\n            this.setAttribute('aria-selected', 'false');\n        }\n        if (this._firstChanged) {\n            this._firstChanged = false;\n            return;\n        }\n        if (this._skipPropRequest) {\n            return;\n        }\n        this.fireRequestSelected(value, 'property');\n    })\n], ListItemBase.prototype, \"selected\", void 0);\n__decorate([\n    state()\n], ListItemBase.prototype, \"shouldRenderRipple\", void 0);\n__decorate([\n    state()\n], ListItemBase.prototype, \"_managingList\", void 0);\n//# sourceMappingURL=mwc-list-item-base.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-radio';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { ListItemBase } from './mwc-list-item-base';\nexport class RadioListItemBase extends ListItemBase {\n    constructor() {\n        super(...arguments);\n        this.left = false;\n        this.graphic = 'control';\n        this._changeFromClick = false;\n    }\n    render() {\n        const radioClasses = {\n            'mdc-deprecated-list-item__graphic': this.left,\n            'mdc-deprecated-list-item__meta': !this.left,\n        };\n        const text = this.renderText();\n        const graphic = this.graphic && this.graphic !== 'control' && !this.left ?\n            this.renderGraphic() :\n            html ``;\n        const meta = this.hasMeta && this.left ? this.renderMeta() : html ``;\n        const ripple = this.renderRipple();\n        return html `\n      ${ripple}\n      ${graphic}\n      ${this.left ? '' : text}\n      <mwc-radio\n          global\n          class=${classMap(radioClasses)}\n          tabindex=${this.tabindex}\n          name=${ifDefined(this.group === null ? undefined : this.group)}\n          .checked=${this.selected}\n          ?disabled=${this.disabled}\n          @checked=${this.onChange}>\n      </mwc-radio>\n      ${this.left ? text : ''}\n      ${meta}`;\n    }\n    onClick() {\n        this._changeFromClick = true;\n        super.onClick();\n    }\n    async onChange(evt) {\n        const checkbox = evt.target;\n        const changeFromProp = this.selected === checkbox.checked;\n        if (!changeFromProp) {\n            this._skipPropRequest = true;\n            this.selected = checkbox.checked;\n            await this.updateComplete;\n            this._skipPropRequest = false;\n            if (!this._changeFromClick) {\n                this.fireRequestSelected(this.selected, 'interaction');\n            }\n        }\n        this._changeFromClick = false;\n    }\n}\n__decorate([\n    query('slot')\n], RadioListItemBase.prototype, \"slotElement\", void 0);\n__decorate([\n    query('mwc-radio')\n], RadioListItemBase.prototype, \"radioElement\", void 0);\n__decorate([\n    property({ type: Boolean })\n], RadioListItemBase.prototype, \"left\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], RadioListItemBase.prototype, \"graphic\", void 0);\n//# sourceMappingURL=mwc-radio-list-item-base.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport { Corner as CornerEnum, CornerBit } from '@material/menu-surface/constants';\nimport MDCMenuSurfaceFoundation from '@material/menu-surface/foundation';\nimport { addHasRemoveClass, BaseElement } from '@material/mwc-base/base-element';\nimport { observer } from '@material/mwc-base/observer';\nimport { deepActiveElementPath, doesElementContainFocus } from '@material/mwc-base/utils';\nimport { html } from 'lit';\nimport { property, query, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { styleMap } from 'lit/directives/style-map.js';\n// tslint:disable:no-bitwise\n// required for closure compiler\nconst stringToCorner = {\n    'TOP_LEFT': CornerEnum.TOP_LEFT,\n    'TOP_RIGHT': CornerEnum.TOP_RIGHT,\n    'BOTTOM_LEFT': CornerEnum.BOTTOM_LEFT,\n    'BOTTOM_RIGHT': CornerEnum.BOTTOM_RIGHT,\n    'TOP_START': CornerEnum.TOP_START,\n    'TOP_END': CornerEnum.TOP_END,\n    'BOTTOM_START': CornerEnum.BOTTOM_START,\n    'BOTTOM_END': CornerEnum.BOTTOM_END,\n};\n/**\n * @fires opened\n * @fires closed\n */\nexport class MenuSurfaceBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.mdcFoundationClass = MDCMenuSurfaceFoundation;\n        this.absolute = false;\n        this.fullwidth = false;\n        this.fixed = false;\n        this.x = null;\n        this.y = null;\n        // must be defined before open or else race condition in foundation occurs.\n        this.quick = false;\n        this.open = false;\n        this.stayOpenOnBodyClick = false;\n        this.bitwiseCorner = CornerEnum.TOP_START;\n        this.previousMenuCorner = null;\n        // must be defined before observer of anchor corner for initialization\n        this.menuCorner = 'START';\n        this.corner = 'TOP_START';\n        this.styleTop = '';\n        this.styleLeft = '';\n        this.styleRight = '';\n        this.styleBottom = '';\n        this.styleMaxHeight = '';\n        this.styleTransformOrigin = '';\n        this.anchor = null;\n        this.previouslyFocused = null;\n        this.previousAnchor = null;\n        this.onBodyClickBound = () => undefined;\n    }\n    render() {\n        const classes = {\n            'mdc-menu-surface--fixed': this.fixed,\n            'mdc-menu-surface--fullwidth': this.fullwidth,\n        };\n        const styles = {\n            'top': this.styleTop,\n            'left': this.styleLeft,\n            'right': this.styleRight,\n            'bottom': this.styleBottom,\n            'max-height': this.styleMaxHeight,\n            'transform-origin': this.styleTransformOrigin,\n        };\n        return html `\n      <div\n          class=\"mdc-menu-surface ${classMap(classes)}\"\n          style=\"${styleMap(styles)}\"\n          @keydown=${this.onKeydown}\n          @opened=${this.registerBodyClick}\n          @closed=${this.deregisterBodyClick}>\n        <slot></slot>\n      </div>`;\n    }\n    createAdapter() {\n        return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { hasAnchor: () => {\n                return !!this.anchor;\n            }, notifyClose: () => {\n                const init = { bubbles: true, composed: true };\n                const ev = new CustomEvent('closed', init);\n                this.open = false;\n                this.mdcRoot.dispatchEvent(ev);\n            }, notifyClosing: () => {\n                const init = { bubbles: true, composed: true };\n                const ev = new CustomEvent('closing', init);\n                this.mdcRoot.dispatchEvent(ev);\n            }, notifyOpen: () => {\n                const init = { bubbles: true, composed: true };\n                const ev = new CustomEvent('opened', init);\n                this.open = true;\n                this.mdcRoot.dispatchEvent(ev);\n            }, isElementInContainer: () => false, isRtl: () => {\n                if (this.mdcRoot) {\n                    return getComputedStyle(this.mdcRoot).direction === 'rtl';\n                }\n                return false;\n            }, setTransformOrigin: (origin) => {\n                const root = this.mdcRoot;\n                if (!root) {\n                    return;\n                }\n                this.styleTransformOrigin = origin;\n            }, isFocused: () => {\n                return doesElementContainFocus(this);\n            }, saveFocus: () => {\n                const activeElementPath = deepActiveElementPath();\n                const pathLength = activeElementPath.length;\n                if (!pathLength) {\n                    this.previouslyFocused = null;\n                }\n                this.previouslyFocused = activeElementPath[pathLength - 1];\n            }, restoreFocus: () => {\n                if (!this.previouslyFocused) {\n                    return;\n                }\n                if ('focus' in this.previouslyFocused) {\n                    this.previouslyFocused.focus();\n                }\n            }, getInnerDimensions: () => {\n                const mdcRoot = this.mdcRoot;\n                if (!mdcRoot) {\n                    return { width: 0, height: 0 };\n                }\n                return { width: mdcRoot.offsetWidth, height: mdcRoot.offsetHeight };\n            }, getAnchorDimensions: () => {\n                const anchorElement = this.anchor;\n                return anchorElement ? anchorElement.getBoundingClientRect() : null;\n            }, getBodyDimensions: () => {\n                return {\n                    width: document.body.clientWidth,\n                    height: document.body.clientHeight,\n                };\n            }, getWindowDimensions: () => {\n                return {\n                    width: window.innerWidth,\n                    height: window.innerHeight,\n                };\n            }, getWindowScroll: () => {\n                return {\n                    x: window.pageXOffset,\n                    y: window.pageYOffset,\n                };\n            }, setPosition: (position) => {\n                const mdcRoot = this.mdcRoot;\n                if (!mdcRoot) {\n                    return;\n                }\n                this.styleLeft = 'left' in position ? `${position.left}px` : '';\n                this.styleRight = 'right' in position ? `${position.right}px` : '';\n                this.styleTop = 'top' in position ? `${position.top}px` : '';\n                this.styleBottom = 'bottom' in position ? `${position.bottom}px` : '';\n            }, setMaxHeight: async (height) => {\n                const mdcRoot = this.mdcRoot;\n                if (!mdcRoot) {\n                    return;\n                }\n                // must set both for IE support as IE will not set a var\n                this.styleMaxHeight = height;\n                await this.updateComplete;\n                this.styleMaxHeight = `var(--mdc-menu-max-height, ${height})`;\n            } });\n    }\n    onKeydown(evt) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.handleKeydown(evt);\n        }\n    }\n    onBodyClick(evt) {\n        if (this.stayOpenOnBodyClick) {\n            return;\n        }\n        const path = evt.composedPath();\n        if (path.indexOf(this) === -1) {\n            this.close();\n        }\n    }\n    registerBodyClick() {\n        this.onBodyClickBound = this.onBodyClick.bind(this);\n        // capture otherwise listener closes menu after quick menu opens\n        document.body.addEventListener('click', this.onBodyClickBound, { passive: true, capture: true });\n    }\n    deregisterBodyClick() {\n        document.body.removeEventListener('click', this.onBodyClickBound, { capture: true });\n    }\n    close() {\n        this.open = false;\n    }\n    show() {\n        this.open = true;\n    }\n}\n__decorate([\n    query('.mdc-menu-surface')\n], MenuSurfaceBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('slot')\n], MenuSurfaceBase.prototype, \"slotElement\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (isAbsolute) {\n        if (this.mdcFoundation && !this.fixed) {\n            this.mdcFoundation.setIsHoisted(isAbsolute);\n        }\n    })\n], MenuSurfaceBase.prototype, \"absolute\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuSurfaceBase.prototype, \"fullwidth\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (isFixed) {\n        if (this.mdcFoundation && !this.absolute) {\n            this.mdcFoundation.setFixedPosition(isFixed);\n        }\n    })\n], MenuSurfaceBase.prototype, \"fixed\", void 0);\n__decorate([\n    property({ type: Number }),\n    observer(function (value) {\n        if (this.mdcFoundation && this.y !== null && value !== null) {\n            this.mdcFoundation.setAbsolutePosition(value, this.y);\n            this.mdcFoundation.setAnchorMargin({ left: value, top: this.y, right: -value, bottom: this.y });\n        }\n    })\n], MenuSurfaceBase.prototype, \"x\", void 0);\n__decorate([\n    property({ type: Number }),\n    observer(function (value) {\n        if (this.mdcFoundation && this.x !== null && value !== null) {\n            this.mdcFoundation.setAbsolutePosition(this.x, value);\n            this.mdcFoundation.setAnchorMargin({ left: this.x, top: value, right: -this.x, bottom: value });\n        }\n    })\n], MenuSurfaceBase.prototype, \"y\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.setQuickOpen(value);\n        }\n    })\n], MenuSurfaceBase.prototype, \"quick\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true }),\n    observer(function (isOpen, wasOpen) {\n        if (this.mdcFoundation) {\n            if (isOpen) {\n                this.mdcFoundation.open();\n                // wasOpen helps with first render (when it is `undefined`) perf\n            }\n            else if (wasOpen !== undefined) {\n                this.mdcFoundation.close();\n            }\n        }\n    })\n], MenuSurfaceBase.prototype, \"open\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuSurfaceBase.prototype, \"stayOpenOnBodyClick\", void 0);\n__decorate([\n    state(),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            if (value) {\n                this.mdcFoundation.setAnchorCorner(value);\n            }\n            else {\n                this.mdcFoundation.setAnchorCorner(value);\n            }\n        }\n    })\n], MenuSurfaceBase.prototype, \"bitwiseCorner\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            const isValidValue = value === 'START' || value === 'END';\n            const isFirstTimeSet = this.previousMenuCorner === null;\n            const cornerChanged = !isFirstTimeSet && value !== this.previousMenuCorner;\n            const initiallySetToEnd = isFirstTimeSet && value === 'END';\n            if (isValidValue && (cornerChanged || initiallySetToEnd)) {\n                this.bitwiseCorner = this.bitwiseCorner ^ CornerBit.RIGHT;\n                this.mdcFoundation.flipCornerHorizontally();\n                this.previousMenuCorner = value;\n            }\n        }\n    })\n], MenuSurfaceBase.prototype, \"menuCorner\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            if (value) {\n                let newCorner = stringToCorner[value];\n                if (this.menuCorner === 'END') {\n                    newCorner = newCorner ^ CornerBit.RIGHT;\n                }\n                this.bitwiseCorner = newCorner;\n            }\n        }\n    })\n], MenuSurfaceBase.prototype, \"corner\", void 0);\n__decorate([\n    state()\n], MenuSurfaceBase.prototype, \"styleTop\", void 0);\n__decorate([\n    state()\n], MenuSurfaceBase.prototype, \"styleLeft\", void 0);\n__decorate([\n    state()\n], MenuSurfaceBase.prototype, \"styleRight\", void 0);\n__decorate([\n    state()\n], MenuSurfaceBase.prototype, \"styleBottom\", void 0);\n__decorate([\n    state()\n], MenuSurfaceBase.prototype, \"styleMaxHeight\", void 0);\n__decorate([\n    state()\n], MenuSurfaceBase.prototype, \"styleTransformOrigin\", void 0);\n//# sourceMappingURL=mwc-menu-surface-base.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-list';\nimport './mwc-menu-surface';\nimport { DefaultFocusState as DefaultFocusStateEnum } from '@material/menu/constants';\nimport MDCMenuFoundation from '@material/menu/foundation';\nimport { BaseElement } from '@material/mwc-base/base-element';\nimport { observer } from '@material/mwc-base/observer';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nexport { createSetFromIndex, isEventMulti, isIndexSet } from '@material/mwc-list/mwc-list-foundation';\n/**\n * @fires selected {SelectedDetail}\n * @fires action {ActionDetail}\n * @fires items-updated\n * @fires opened\n * @fires closed\n */\nexport class MenuBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.mdcFoundationClass = MDCMenuFoundation;\n        this.listElement_ = null;\n        this.anchor = null;\n        this.open = false;\n        this.quick = false;\n        this.wrapFocus = false;\n        this.innerRole = 'menu';\n        this.innerAriaLabel = null;\n        this.corner = 'TOP_START';\n        this.x = null;\n        this.y = null;\n        this.absolute = false;\n        this.multi = false;\n        this.activatable = false;\n        this.fixed = false;\n        this.forceGroupSelection = false;\n        this.fullwidth = false;\n        this.menuCorner = 'START';\n        this.stayOpenOnBodyClick = false;\n        this.defaultFocus = 'LIST_ROOT';\n        this._listUpdateComplete = null;\n    }\n    get listElement() {\n        if (!this.listElement_) {\n            this.listElement_ = this.renderRoot.querySelector('mwc-list');\n            return this.listElement_;\n        }\n        return this.listElement_;\n    }\n    get items() {\n        const listElement = this.listElement;\n        if (listElement) {\n            return listElement.items;\n        }\n        return [];\n    }\n    get index() {\n        const listElement = this.listElement;\n        if (listElement) {\n            return listElement.index;\n        }\n        return -1;\n    }\n    get selected() {\n        const listElement = this.listElement;\n        if (listElement) {\n            return listElement.selected;\n        }\n        return null;\n    }\n    render() {\n        const itemRoles = this.innerRole === 'menu' ? 'menuitem' : 'option';\n        return html `\n      <mwc-menu-surface\n          ?hidden=${!this.open}\n          .anchor=${this.anchor}\n          .open=${this.open}\n          .quick=${this.quick}\n          .corner=${this.corner}\n          .x=${this.x}\n          .y=${this.y}\n          .absolute=${this.absolute}\n          .fixed=${this.fixed}\n          .fullwidth=${this.fullwidth}\n          .menuCorner=${this.menuCorner}\n          ?stayOpenOnBodyClick=${this.stayOpenOnBodyClick}\n          class=\"mdc-menu mdc-menu-surface\"\n          @closed=${this.onClosed}\n          @opened=${this.onOpened}\n          @keydown=${this.onKeydown}>\n        <mwc-list\n          rootTabbable\n          .innerAriaLabel=${this.innerAriaLabel}\n          .innerRole=${this.innerRole}\n          .multi=${this.multi}\n          class=\"mdc-deprecated-list\"\n          .itemRoles=${itemRoles}\n          .wrapFocus=${this.wrapFocus}\n          .activatable=${this.activatable}\n          @action=${this.onAction}>\n        <slot></slot>\n      </mwc-list>\n    </mwc-menu-surface>`;\n    }\n    createAdapter() {\n        return {\n            addClassToElementAtIndex: (index, className) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return;\n                }\n                const element = listElement.items[index];\n                if (!element) {\n                    return;\n                }\n                if (className === 'mdc-menu-item--selected') {\n                    if (this.forceGroupSelection && !element.selected) {\n                        listElement.toggle(index, true);\n                    }\n                }\n                else {\n                    element.classList.add(className);\n                }\n            },\n            removeClassFromElementAtIndex: (index, className) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return;\n                }\n                const element = listElement.items[index];\n                if (!element) {\n                    return;\n                }\n                if (className === 'mdc-menu-item--selected') {\n                    if (element.selected) {\n                        listElement.toggle(index, false);\n                    }\n                }\n                else {\n                    element.classList.remove(className);\n                }\n            },\n            addAttributeToElementAtIndex: (index, attr, value) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return;\n                }\n                const element = listElement.items[index];\n                if (!element) {\n                    return;\n                }\n                element.setAttribute(attr, value);\n            },\n            removeAttributeFromElementAtIndex: (index, attr) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return;\n                }\n                const element = listElement.items[index];\n                if (!element) {\n                    return;\n                }\n                element.removeAttribute(attr);\n            },\n            getAttributeFromElementAtIndex: (index, attr) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return null;\n                }\n                const element = listElement.items[index];\n                if (!element) {\n                    return null;\n                }\n                return element.getAttribute(attr);\n            },\n            elementContainsClass: (element, className) => element.classList.contains(className),\n            closeSurface: () => {\n                this.open = false;\n            },\n            getElementIndex: (element) => {\n                const listElement = this.listElement;\n                if (listElement) {\n                    return listElement.items.indexOf(element);\n                }\n                return -1;\n            },\n            notifySelected: () => { },\n            getMenuItemCount: () => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return 0;\n                }\n                return listElement.items.length;\n            },\n            focusItemAtIndex: (index) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return;\n                }\n                const element = listElement.items[index];\n                if (element) {\n                    element.focus();\n                }\n            },\n            focusListRoot: () => {\n                if (this.listElement) {\n                    this.listElement.focus();\n                }\n            },\n            getSelectedSiblingOfItemAtIndex: (index) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return -1;\n                }\n                const elementAtIndex = listElement.items[index];\n                if (!elementAtIndex || !elementAtIndex.group) {\n                    return -1;\n                }\n                for (let i = 0; i < listElement.items.length; i++) {\n                    if (i === index) {\n                        continue;\n                    }\n                    const current = listElement.items[i];\n                    if (current.selected && current.group === elementAtIndex.group) {\n                        return i;\n                    }\n                }\n                return -1;\n            },\n            isSelectableItemAtIndex: (index) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return false;\n                }\n                const elementAtIndex = listElement.items[index];\n                if (!elementAtIndex) {\n                    return false;\n                }\n                return elementAtIndex.hasAttribute('group');\n            },\n        };\n    }\n    onKeydown(evt) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.handleKeydown(evt);\n        }\n    }\n    onAction(evt) {\n        const listElement = this.listElement;\n        if (this.mdcFoundation && listElement) {\n            const index = evt.detail.index;\n            const el = listElement.items[index];\n            if (el) {\n                this.mdcFoundation.handleItemAction(el);\n            }\n        }\n    }\n    onOpened() {\n        this.open = true;\n        if (this.mdcFoundation) {\n            this.mdcFoundation.handleMenuSurfaceOpened();\n        }\n    }\n    onClosed() {\n        this.open = false;\n    }\n    // tslint:disable:ban-ts-ignore\n    async getUpdateComplete() {\n        await this._listUpdateComplete;\n        // @ts-ignore\n        const result = await super.getUpdateComplete();\n        return result;\n    }\n    // tslint:enable:ban-ts-ignore\n    async firstUpdated() {\n        super.firstUpdated();\n        const listElement = this.listElement;\n        if (listElement) {\n            this._listUpdateComplete = listElement.updateComplete;\n            await this._listUpdateComplete;\n        }\n    }\n    select(index) {\n        const listElement = this.listElement;\n        if (listElement) {\n            listElement.select(index);\n        }\n    }\n    close() {\n        this.open = false;\n    }\n    show() {\n        this.open = true;\n    }\n    getFocusedItemIndex() {\n        const listElement = this.listElement;\n        if (listElement) {\n            return listElement.getFocusedItemIndex();\n        }\n        return -1;\n    }\n    focusItemAtIndex(index) {\n        const listElement = this.listElement;\n        if (listElement) {\n            listElement.focusItemAtIndex(index);\n        }\n    }\n    layout(updateItems = true) {\n        const listElement = this.listElement;\n        if (listElement) {\n            listElement.layout(updateItems);\n        }\n    }\n}\n__decorate([\n    query('.mdc-menu')\n], MenuBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('slot')\n], MenuBase.prototype, \"slotElement\", void 0);\n__decorate([\n    property({ type: Object })\n], MenuBase.prototype, \"anchor\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], MenuBase.prototype, \"open\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"quick\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"wrapFocus\", void 0);\n__decorate([\n    property({ type: String })\n], MenuBase.prototype, \"innerRole\", void 0);\n__decorate([\n    property({ type: String })\n], MenuBase.prototype, \"innerAriaLabel\", void 0);\n__decorate([\n    property({ type: String })\n], MenuBase.prototype, \"corner\", void 0);\n__decorate([\n    property({ type: Number })\n], MenuBase.prototype, \"x\", void 0);\n__decorate([\n    property({ type: Number })\n], MenuBase.prototype, \"y\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"absolute\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"multi\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"activatable\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"fixed\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"forceGroupSelection\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"fullwidth\", void 0);\n__decorate([\n    property({ type: String })\n], MenuBase.prototype, \"menuCorner\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"stayOpenOnBodyClick\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.setDefaultFocusState(DefaultFocusStateEnum[value]);\n        }\n    })\n], MenuBase.prototype, \"defaultFocus\", void 0);\n//# sourceMappingURL=mwc-menu-base.js.map","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport { BaseElement } from '@material/mwc-base/base-element';\nimport { MDCNotchedOutlineFoundation } from '@material/notched-outline/foundation';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nexport class NotchedOutlineBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.mdcFoundationClass = MDCNotchedOutlineFoundation;\n        this.width = 0;\n        this.open = false;\n        this.lastOpen = this.open;\n    }\n    createAdapter() {\n        return {\n            addClass: (className) => this.mdcRoot.classList.add(className),\n            removeClass: (className) => this.mdcRoot.classList.remove(className),\n            setNotchWidthProperty: (width) => this.notchElement.style.setProperty('width', `${width}px`),\n            removeNotchWidthProperty: () => this.notchElement.style.removeProperty('width'),\n        };\n    }\n    openOrClose(shouldOpen, width) {\n        if (!this.mdcFoundation) {\n            return;\n        }\n        if (shouldOpen && width !== undefined) {\n            this.mdcFoundation.notch(width);\n        }\n        else {\n            this.mdcFoundation.closeNotch();\n        }\n    }\n    render() {\n        this.openOrClose(this.open, this.width);\n        const classes = classMap({\n            'mdc-notched-outline--notched': this.open,\n        });\n        return html `\n      <span class=\"mdc-notched-outline ${classes}\">\n        <span class=\"mdc-notched-outline__leading\"></span>\n        <span class=\"mdc-notched-outline__notch\">\n          <slot></slot>\n        </span>\n        <span class=\"mdc-notched-outline__trailing\"></span>\n      </span>`;\n    }\n}\n__decorate([\n    query('.mdc-notched-outline')\n], NotchedOutlineBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    property({ type: Number })\n], NotchedOutlineBase.prototype, \"width\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], NotchedOutlineBase.prototype, \"open\", void 0);\n__decorate([\n    query('.mdc-notched-outline__notch')\n], NotchedOutlineBase.prototype, \"notchElement\", void 0);\n//# sourceMappingURL=mwc-notched-outline-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-ripple/mwc-ripple';\nimport { ariaProperty } from '@material/mwc-base/aria-property';\nimport { addHasRemoveClass, FormElement } from '@material/mwc-base/form-element';\nimport { observer } from '@material/mwc-base/observer';\nimport { SingleSelectionController } from '@material/mwc-radio/single-selection-controller';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers';\nimport MDCRadioFoundation from '@material/radio/foundation';\nimport { html } from 'lit';\nimport { eventOptions, property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\n/**\n * @fires checked\n * @soyCompatible\n */\nexport class RadioBase extends FormElement {\n    constructor() {\n        super(...arguments);\n        this._checked = false;\n        this.useStateLayerCustomProperties = false;\n        this.global = false;\n        this.disabled = false;\n        this.value = 'on';\n        this.name = '';\n        /**\n         * Touch target extends beyond visual boundary of a component by default.\n         * Set to `true` to remove touch target added to the component.\n         * @see https://material.io/design/usability/accessibility.html\n         */\n        this.reducedTouchTarget = false;\n        this.mdcFoundationClass = MDCRadioFoundation;\n        /**\n         * input's tabindex is updated based on checked status.\n         * Tab navigation will be removed from unchecked radios.\n         */\n        this.formElementTabIndex = 0;\n        this.focused = false;\n        this.shouldRenderRipple = false;\n        this.rippleElement = null;\n        this.rippleHandlers = new RippleHandlers(() => {\n            this.shouldRenderRipple = true;\n            this.ripple.then((v) => {\n                this.rippleElement = v;\n            });\n            return this.ripple;\n        });\n    }\n    get checked() {\n        return this._checked;\n    }\n    /**\n     * We define our own getter/setter for `checked` because we need to track\n     * changes to it synchronously.\n     *\n     * The order in which the `checked` property is set across radio buttons\n     * within the same group is very important. However, we can't rely on\n     * UpdatingElement's `updated` callback to observe these changes (which is\n     * also what the `@observer` decorator uses), because it batches changes to\n     * all properties.\n     *\n     * Consider:\n     *\n     *   radio1.disabled = true;\n     *   radio2.checked = true;\n     *   radio1.checked = true;\n     *\n     * In this case we'd first see all changes for radio1, and then for radio2,\n     * and we couldn't tell that radio1 was the most recently checked.\n     */\n    set checked(isChecked) {\n        var _a, _b;\n        const oldValue = this._checked;\n        if (isChecked === oldValue) {\n            return;\n        }\n        this._checked = isChecked;\n        if (this.formElement) {\n            this.formElement.checked = isChecked;\n        }\n        (_a = this._selectionController) === null || _a === void 0 ? void 0 : _a.update(this);\n        if (isChecked === false) {\n            // Remove focus ring when unchecked on other radio programmatically.\n            // Blur on input since this determines the focus style.\n            (_b = this.formElement) === null || _b === void 0 ? void 0 : _b.blur();\n        }\n        this.requestUpdate('checked', oldValue);\n        // useful when unchecks self and wrapping element needs to synchronize\n        // TODO(b/168543810): Remove triggering event on programmatic API call.\n        this.dispatchEvent(new Event('checked', { bubbles: true, composed: true }));\n    }\n    _handleUpdatedValue(newValue) {\n        // the observer function can't access protected fields (according to\n        // closure compiler) because it's not a method on the class, so we need this\n        // wrapper.\n        this.formElement.value = newValue;\n    }\n    /** @soyTemplate */\n    renderRipple() {\n        return this.shouldRenderRipple ? html `<mwc-ripple unbounded accent\n        .internalUseStateLayerCustomProperties=\"${this.useStateLayerCustomProperties}\"\n        .disabled=\"${this.disabled}\"></mwc-ripple>` :\n            '';\n    }\n    get isRippleActive() {\n        var _a;\n        return ((_a = this.rippleElement) === null || _a === void 0 ? void 0 : _a.isActive) || false;\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        // Note that we must defer creating the selection controller until the\n        // element has connected, because selection controllers are keyed by the\n        // radio's shadow root. For example, if we're stamping in a lit map\n        // or repeat, then we'll be constructed before we're added to a root node.\n        //\n        // Also note if we aren't using native shadow DOM, we still need a\n        // SelectionController, because we should update checked status of other\n        // radios in the group when selection changes. It also simplifies\n        // implementation and testing to use one in all cases.\n        //\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        this._selectionController = SingleSelectionController.getController(this);\n        this._selectionController.register(this);\n        // Radios maybe checked before connected, update selection as soon it is\n        // connected to DOM. Last checked radio button in the DOM will be selected.\n        //\n        // NOTE: If we update selection only after firstUpdate() we might mistakenly\n        // update checked status before other radios are rendered.\n        this._selectionController.update(this);\n    }\n    disconnectedCallback() {\n        // The controller is initialized in connectedCallback, so if we are in\n        // disconnectedCallback then it must be initialized.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this._selectionController.unregister(this);\n        this._selectionController = undefined;\n    }\n    focus() {\n        this.formElement.focus();\n    }\n    createAdapter() {\n        return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { setNativeControlDisabled: (disabled) => {\n                this.formElement.disabled = disabled;\n            } });\n    }\n    handleFocus() {\n        this.focused = true;\n        this.handleRippleFocus();\n    }\n    handleClick() {\n        // Firefox has weird behavior with radios if they are not focused\n        this.formElement.focus();\n    }\n    handleBlur() {\n        this.focused = false;\n        this.formElement.blur();\n        this.rippleHandlers.endFocus();\n    }\n    setFormData(formData) {\n        if (this.name && this.checked) {\n            formData.append(this.name, this.value);\n        }\n    }\n    /**\n     * @soyTemplate\n     * @soyAttributes radioAttributes: input\n     * @soyClasses radioClasses: .mdc-radio\n     */\n    render() {\n        /** @classMap */\n        const classes = {\n            'mdc-radio--touch': !this.reducedTouchTarget,\n            'mdc-ripple-upgraded--background-focused': this.focused,\n            'mdc-radio--disabled': this.disabled,\n        };\n        return html `\n      <div class=\"mdc-radio ${classMap(classes)}\">\n        <input\n          tabindex=\"${this.formElementTabIndex}\"\n          class=\"mdc-radio__native-control\"\n          type=\"radio\"\n          name=\"${this.name}\"\n          aria-label=\"${ifDefined(this.ariaLabel)}\"\n          aria-labelledby=\"${ifDefined(this.ariaLabelledBy)}\"\n          .checked=\"${this.checked}\"\n          .value=\"${this.value}\"\n          ?disabled=\"${this.disabled}\"\n          @change=\"${this.changeHandler}\"\n          @focus=\"${this.handleFocus}\"\n          @click=\"${this.handleClick}\"\n          @blur=\"${this.handleBlur}\"\n          @mousedown=\"${this.handleRippleMouseDown}\"\n          @mouseenter=\"${this.handleRippleMouseEnter}\"\n          @mouseleave=\"${this.handleRippleMouseLeave}\"\n          @touchstart=\"${this.handleRippleTouchStart}\"\n          @touchend=\"${this.handleRippleDeactivate}\"\n          @touchcancel=\"${this.handleRippleDeactivate}\">\n        <div class=\"mdc-radio__background\">\n          <div class=\"mdc-radio__outer-circle\"></div>\n          <div class=\"mdc-radio__inner-circle\"></div>\n        </div>\n        ${this.renderRipple()}\n      </div>`;\n    }\n    handleRippleMouseDown(event) {\n        const onUp = () => {\n            window.removeEventListener('mouseup', onUp);\n            this.handleRippleDeactivate();\n        };\n        window.addEventListener('mouseup', onUp);\n        this.rippleHandlers.startPress(event);\n    }\n    handleRippleTouchStart(event) {\n        this.rippleHandlers.startPress(event);\n    }\n    handleRippleDeactivate() {\n        this.rippleHandlers.endPress();\n    }\n    handleRippleMouseEnter() {\n        this.rippleHandlers.startHover();\n    }\n    handleRippleMouseLeave() {\n        this.rippleHandlers.endHover();\n    }\n    handleRippleFocus() {\n        this.rippleHandlers.startFocus();\n    }\n    changeHandler() {\n        this.checked = this.formElement.checked;\n    }\n}\n__decorate([\n    query('.mdc-radio')\n], RadioBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('input')\n], RadioBase.prototype, \"formElement\", void 0);\n__decorate([\n    state()\n], RadioBase.prototype, \"useStateLayerCustomProperties\", void 0);\n__decorate([\n    property({ type: Boolean })\n], RadioBase.prototype, \"global\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], RadioBase.prototype, \"checked\", null);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (disabled) {\n        this.mdcFoundation.setDisabled(disabled);\n    })\n], RadioBase.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (value) {\n        this._handleUpdatedValue(value);\n    })\n], RadioBase.prototype, \"value\", void 0);\n__decorate([\n    property({ type: String })\n], RadioBase.prototype, \"name\", void 0);\n__decorate([\n    property({ type: Boolean })\n], RadioBase.prototype, \"reducedTouchTarget\", void 0);\n__decorate([\n    property({ type: Number })\n], RadioBase.prototype, \"formElementTabIndex\", void 0);\n__decorate([\n    state()\n], RadioBase.prototype, \"focused\", void 0);\n__decorate([\n    state()\n], RadioBase.prototype, \"shouldRenderRipple\", void 0);\n__decorate([\n    queryAsync('mwc-ripple')\n], RadioBase.prototype, \"ripple\", void 0);\n__decorate([\n    ariaProperty,\n    property({ attribute: 'aria-label' })\n], RadioBase.prototype, \"ariaLabel\", void 0);\n__decorate([\n    ariaProperty,\n    property({ attribute: 'aria-labelledby' })\n], RadioBase.prototype, \"ariaLabelledBy\", void 0);\n__decorate([\n    eventOptions({ passive: true })\n], RadioBase.prototype, \"handleRippleTouchStart\", null);\n//# sourceMappingURL=mwc-radio-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport { matches } from '@material/dom/ponyfill';\nimport { BaseElement } from '@material/mwc-base/base-element';\nimport MDCRippleFoundation from '@material/ripple/foundation';\nimport { html } from 'lit';\nimport { property, query, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { styleMap } from 'lit/directives/style-map.js';\n/** @soyCompatible */\nexport class RippleBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.primary = false;\n        this.accent = false;\n        this.unbounded = false;\n        this.disabled = false;\n        this.activated = false;\n        this.selected = false;\n        this.internalUseStateLayerCustomProperties = false;\n        this.hovering = false;\n        this.bgFocused = false;\n        this.fgActivation = false;\n        this.fgDeactivation = false;\n        this.fgScale = '';\n        this.fgSize = '';\n        this.translateStart = '';\n        this.translateEnd = '';\n        this.leftPos = '';\n        this.topPos = '';\n        this.mdcFoundationClass = MDCRippleFoundation;\n    }\n    get isActive() {\n        return matches(this.parentElement || this, ':active');\n    }\n    createAdapter() {\n        return {\n            browserSupportsCssVars: () => true,\n            isUnbounded: () => this.unbounded,\n            isSurfaceActive: () => this.isActive,\n            isSurfaceDisabled: () => this.disabled,\n            addClass: (className) => {\n                switch (className) {\n                    case 'mdc-ripple-upgraded--background-focused':\n                        this.bgFocused = true;\n                        break;\n                    case 'mdc-ripple-upgraded--foreground-activation':\n                        this.fgActivation = true;\n                        break;\n                    case 'mdc-ripple-upgraded--foreground-deactivation':\n                        this.fgDeactivation = true;\n                        break;\n                    default:\n                        break;\n                }\n            },\n            removeClass: (className) => {\n                switch (className) {\n                    case 'mdc-ripple-upgraded--background-focused':\n                        this.bgFocused = false;\n                        break;\n                    case 'mdc-ripple-upgraded--foreground-activation':\n                        this.fgActivation = false;\n                        break;\n                    case 'mdc-ripple-upgraded--foreground-deactivation':\n                        this.fgDeactivation = false;\n                        break;\n                    default:\n                        break;\n                }\n            },\n            containsEventTarget: () => true,\n            registerInteractionHandler: () => undefined,\n            deregisterInteractionHandler: () => undefined,\n            registerDocumentInteractionHandler: () => undefined,\n            deregisterDocumentInteractionHandler: () => undefined,\n            registerResizeHandler: () => undefined,\n            deregisterResizeHandler: () => undefined,\n            updateCssVariable: (varName, value) => {\n                switch (varName) {\n                    case '--mdc-ripple-fg-scale':\n                        this.fgScale = value;\n                        break;\n                    case '--mdc-ripple-fg-size':\n                        this.fgSize = value;\n                        break;\n                    case '--mdc-ripple-fg-translate-end':\n                        this.translateEnd = value;\n                        break;\n                    case '--mdc-ripple-fg-translate-start':\n                        this.translateStart = value;\n                        break;\n                    case '--mdc-ripple-left':\n                        this.leftPos = value;\n                        break;\n                    case '--mdc-ripple-top':\n                        this.topPos = value;\n                        break;\n                    default:\n                        break;\n                }\n            },\n            computeBoundingRect: () => (this.parentElement || this).getBoundingClientRect(),\n            getWindowPageOffset: () => ({ x: window.pageXOffset, y: window.pageYOffset }),\n        };\n    }\n    startPress(ev) {\n        this.waitForFoundation(() => {\n            this.mdcFoundation.activate(ev);\n        });\n    }\n    endPress() {\n        this.waitForFoundation(() => {\n            this.mdcFoundation.deactivate();\n        });\n    }\n    startFocus() {\n        this.waitForFoundation(() => {\n            this.mdcFoundation.handleFocus();\n        });\n    }\n    endFocus() {\n        this.waitForFoundation(() => {\n            this.mdcFoundation.handleBlur();\n        });\n    }\n    startHover() {\n        this.hovering = true;\n    }\n    endHover() {\n        this.hovering = false;\n    }\n    /**\n     * Wait for the MDCFoundation to be created by `firstUpdated`\n     */\n    waitForFoundation(fn) {\n        if (this.mdcFoundation) {\n            fn();\n        }\n        else {\n            this.updateComplete.then(fn);\n        }\n    }\n    update(changedProperties) {\n        if (changedProperties.has('disabled')) {\n            // stop hovering when ripple is disabled to prevent a stuck \"hover\" state\n            // When re-enabled, the outer component will get a `mouseenter` event on\n            // the first movement, which will call `startHover()`\n            if (this.disabled) {\n                this.endHover();\n            }\n        }\n        super.update(changedProperties);\n    }\n    /** @soyTemplate */\n    render() {\n        const shouldActivateInPrimary = this.activated && (this.primary || !this.accent);\n        const shouldSelectInPrimary = this.selected && (this.primary || !this.accent);\n        /** @classMap */\n        const classes = {\n            'mdc-ripple-surface--accent': this.accent,\n            'mdc-ripple-surface--primary--activated': shouldActivateInPrimary,\n            'mdc-ripple-surface--accent--activated': this.accent && this.activated,\n            'mdc-ripple-surface--primary--selected': shouldSelectInPrimary,\n            'mdc-ripple-surface--accent--selected': this.accent && this.selected,\n            'mdc-ripple-surface--disabled': this.disabled,\n            'mdc-ripple-surface--hover': this.hovering,\n            'mdc-ripple-surface--primary': this.primary,\n            'mdc-ripple-surface--selected': this.selected,\n            'mdc-ripple-upgraded--background-focused': this.bgFocused,\n            'mdc-ripple-upgraded--foreground-activation': this.fgActivation,\n            'mdc-ripple-upgraded--foreground-deactivation': this.fgDeactivation,\n            'mdc-ripple-upgraded--unbounded': this.unbounded,\n            'mdc-ripple-surface--internal-use-state-layer-custom-properties': this.internalUseStateLayerCustomProperties,\n        };\n        return html `\n        <div class=\"mdc-ripple-surface mdc-ripple-upgraded ${classMap(classes)}\"\n          style=\"${styleMap({\n            '--mdc-ripple-fg-scale': this.fgScale,\n            '--mdc-ripple-fg-size': this.fgSize,\n            '--mdc-ripple-fg-translate-end': this.translateEnd,\n            '--mdc-ripple-fg-translate-start': this.translateStart,\n            '--mdc-ripple-left': this.leftPos,\n            '--mdc-ripple-top': this.topPos,\n        })}\"></div>`;\n    }\n}\n__decorate([\n    query('.mdc-ripple-surface')\n], RippleBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    property({ type: Boolean })\n], RippleBase.prototype, \"primary\", void 0);\n__decorate([\n    property({ type: Boolean })\n], RippleBase.prototype, \"accent\", void 0);\n__decorate([\n    property({ type: Boolean })\n], RippleBase.prototype, \"unbounded\", void 0);\n__decorate([\n    property({ type: Boolean })\n], RippleBase.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean })\n], RippleBase.prototype, \"activated\", void 0);\n__decorate([\n    property({ type: Boolean })\n], RippleBase.prototype, \"selected\", void 0);\n__decorate([\n    property({ type: Boolean })\n], RippleBase.prototype, \"internalUseStateLayerCustomProperties\", void 0);\n__decorate([\n    state()\n], RippleBase.prototype, \"hovering\", void 0);\n__decorate([\n    state()\n], RippleBase.prototype, \"bgFocused\", void 0);\n__decorate([\n    state()\n], RippleBase.prototype, \"fgActivation\", void 0);\n__decorate([\n    state()\n], RippleBase.prototype, \"fgDeactivation\", void 0);\n__decorate([\n    state()\n], RippleBase.prototype, \"fgScale\", void 0);\n__decorate([\n    state()\n], RippleBase.prototype, \"fgSize\", void 0);\n__decorate([\n    state()\n], RippleBase.prototype, \"translateStart\", void 0);\n__decorate([\n    state()\n], RippleBase.prototype, \"translateEnd\", void 0);\n__decorate([\n    state()\n], RippleBase.prototype, \"leftPos\", void 0);\n__decorate([\n    state()\n], RippleBase.prototype, \"topPos\", void 0);\n//# sourceMappingURL=mwc-ripple-base.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-notched-outline';\nimport '@material/mwc-menu';\nimport '@material/mwc-icon/mwc-icon';\nimport { KEY, normalizeKey } from '@material/dom/keyboard';\nimport * as typeahead from '@material/list/typeahead';\nimport { addHasRemoveClass, FormElement } from '@material/mwc-base/form-element';\nimport { observer } from '@material/mwc-base/observer';\nimport { isNodeElement } from '@material/mwc-base/utils';\nimport { floatingLabel } from '@material/mwc-floating-label';\nimport { lineRipple } from '@material/mwc-line-ripple';\nimport MDCSelectFoundation from '@material/select/foundation';\nimport { html, nothing } from 'lit';\nimport { eventOptions, property, query, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nconst createValidityObj = (customValidity = {}) => {\n    /*\n     * We need to make ValidityState an object because it is readonly and\n     * we cannot use the spread operator. Also, we don't export\n     * `CustomValidityState` because it is a leaky implementation and the user\n     * already has access to `ValidityState` in lib.dom.ts. Also an interface\n     * {a: Type} can be casted to {readonly a: Type} so passing any object\n     * should be fine.\n     */\n    const objectifiedCustomValidity = {};\n    // eslint-disable-next-line guard-for-in\n    for (const propName in customValidity) {\n        /*\n         * Casting is needed because ValidityState's props are all readonly and\n         * thus cannot be set on `onjectifiedCustomValidity`. In the end, the\n         * interface is the same as ValidityState (but not readonly), but the\n         * function signature casts the output to ValidityState (thus readonly).\n         */\n        objectifiedCustomValidity[propName] =\n            customValidity[propName];\n    }\n    return Object.assign({ badInput: false, customError: false, patternMismatch: false, rangeOverflow: false, rangeUnderflow: false, stepMismatch: false, tooLong: false, tooShort: false, typeMismatch: false, valid: true, valueMissing: false }, objectifiedCustomValidity);\n};\n/**\n * @fires selected {SelectedDetail}\n * @fires action {ActionDetail}\n * @fires opened\n * @fires closed\n * @fires change\n * @fires invalid\n */\nexport class SelectBase extends FormElement {\n    constructor() {\n        super(...arguments);\n        this.mdcFoundationClass = MDCSelectFoundation;\n        this.disabled = false;\n        this.outlined = false;\n        this.label = '';\n        this.outlineOpen = false;\n        this.outlineWidth = 0;\n        this.value = '';\n        this.name = '';\n        this.selectedText = '';\n        this.icon = '';\n        this.menuOpen = false;\n        this.helper = '';\n        this.validateOnInitialRender = false;\n        this.validationMessage = '';\n        this.required = false;\n        this.naturalMenuWidth = false;\n        this.isUiValid = true;\n        this.fixedMenuPosition = false;\n        // Transiently holds current typeahead prefix from user.\n        this.typeaheadState = typeahead.initState();\n        this.sortedIndexByFirstChar = new Map();\n        this.menuElement_ = null;\n        this.listeners = [];\n        this.onBodyClickBound = () => undefined;\n        this._menuUpdateComplete = null;\n        this.valueSetDirectly = false;\n        this.validityTransform = null;\n        this._validity = createValidityObj();\n    }\n    get items() {\n        // memoize menuElement to prevent unnecessary querySelector calls.\n        if (!this.menuElement_) {\n            this.menuElement_ = this.menuElement;\n        }\n        if (this.menuElement_) {\n            return this.menuElement_.items;\n        }\n        return [];\n    }\n    get selected() {\n        const menuElement = this.menuElement;\n        if (menuElement) {\n            return menuElement.selected;\n        }\n        return null;\n    }\n    get index() {\n        const menuElement = this.menuElement;\n        if (menuElement) {\n            return menuElement.index;\n        }\n        return -1;\n    }\n    get shouldRenderHelperText() {\n        return !!this.helper || !!this.validationMessage;\n    }\n    get validity() {\n        this._checkValidity(this.value);\n        return this._validity;\n    }\n    render() {\n        const classes = {\n            'mdc-select--disabled': this.disabled,\n            'mdc-select--no-label': !this.label,\n            'mdc-select--filled': !this.outlined,\n            'mdc-select--outlined': this.outlined,\n            'mdc-select--with-leading-icon': !!this.icon,\n            'mdc-select--required': this.required,\n            'mdc-select--invalid': !this.isUiValid,\n        };\n        const menuClasses = {\n            'mdc-select__menu--invalid': !this.isUiValid,\n        };\n        const labelledby = !!this.label ? 'label' : undefined;\n        const describedby = this.shouldRenderHelperText ? 'helper-text' : undefined;\n        return html `\n      <div\n          class=\"mdc-select ${classMap(classes)}\">\n        <input\n            class=\"formElement\"\n            name=\"${this.name}\"\n            .value=\"${this.value}\"\n            hidden\n            ?disabled=\"${this.disabled}\"\n            ?required=${this.required}>\n        <!-- @ts-ignore -->\n        <div class=\"mdc-select__anchor\"\n            aria-autocomplete=\"none\"\n            role=\"combobox\"\n            aria-expanded=${this.menuOpen}\n            aria-invalid=${!this.isUiValid}\n            aria-haspopup=\"listbox\"\n            aria-labelledby=${ifDefined(labelledby)}\n            aria-required=${this.required}\n            aria-describedby=${ifDefined(describedby)}\n            @click=${this.onClick}\n            @focus=${this.onFocus}\n            @blur=${this.onBlur}\n            @keydown=${this.onKeydown}>\n          ${this.renderRipple()}\n          ${this.outlined ? this.renderOutline() : this.renderLabel()}\n          ${this.renderLeadingIcon()}\n          <span class=\"mdc-select__selected-text-container\">\n            <span class=\"mdc-select__selected-text\">${this.selectedText}</span>\n          </span>\n          <span class=\"mdc-select__dropdown-icon\">\n            <svg\n                class=\"mdc-select__dropdown-icon-graphic\"\n                viewBox=\"7 10 10 5\"\n                focusable=\"false\">\n              <polygon\n                  class=\"mdc-select__dropdown-icon-inactive\"\n                  stroke=\"none\"\n                  fill-rule=\"evenodd\"\n                  points=\"7 10 12 15 17 10\">\n              </polygon>\n              <polygon\n                  class=\"mdc-select__dropdown-icon-active\"\n                  stroke=\"none\"\n                  fill-rule=\"evenodd\"\n                  points=\"7 15 12 10 17 15\">\n              </polygon>\n            </svg>\n          </span>\n          ${this.renderLineRipple()}\n        </div>\n        <mwc-menu\n            innerRole=\"listbox\"\n            wrapFocus\n            class=\"mdc-select__menu mdc-menu mdc-menu-surface ${classMap(menuClasses)}\"\n            activatable\n            .fullwidth=${this.fixedMenuPosition ? false : !this.naturalMenuWidth}\n            .open=${this.menuOpen}\n            .anchor=${this.anchorElement}\n            .fixed=${this.fixedMenuPosition}\n            @selected=${this.onSelected}\n            @opened=${this.onOpened}\n            @closed=${this.onClosed}\n            @items-updated=${this.onItemsUpdated}\n            @keydown=${this.handleTypeahead}>\n          <slot></slot>\n        </mwc-menu>\n      </div>\n      ${this.renderHelperText()}`;\n    }\n    renderRipple() {\n        if (this.outlined) {\n            return nothing;\n        }\n        return html `\n      <span class=\"mdc-select__ripple\"></span>\n    `;\n    }\n    renderOutline() {\n        if (!this.outlined) {\n            return nothing;\n        }\n        return html `\n      <mwc-notched-outline\n          .width=${this.outlineWidth}\n          .open=${this.outlineOpen}\n          class=\"mdc-notched-outline\">\n        ${this.renderLabel()}\n      </mwc-notched-outline>`;\n    }\n    renderLabel() {\n        if (!this.label) {\n            return nothing;\n        }\n        return html `\n      <span\n          .floatingLabelFoundation=${floatingLabel(this.label)}\n          id=\"label\">${this.label}</span>\n    `;\n    }\n    renderLeadingIcon() {\n        if (!this.icon) {\n            return nothing;\n        }\n        return html `<mwc-icon class=\"mdc-select__icon\"><div>${this.icon}</div></mwc-icon>`;\n    }\n    renderLineRipple() {\n        if (this.outlined) {\n            return nothing;\n        }\n        return html `\n      <span .lineRippleFoundation=${lineRipple()}></span>\n    `;\n    }\n    renderHelperText() {\n        if (!this.shouldRenderHelperText) {\n            return nothing;\n        }\n        const showValidationMessage = this.validationMessage && !this.isUiValid;\n        const classes = {\n            'mdc-select-helper-text--validation-msg': showValidationMessage,\n        };\n        return html `\n        <p\n          class=\"mdc-select-helper-text ${classMap(classes)}\"\n          id=\"helper-text\">${showValidationMessage ? this.validationMessage : this.helper}</p>`;\n    }\n    createAdapter() {\n        return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { activateBottomLine: () => {\n                if (this.lineRippleElement) {\n                    this.lineRippleElement.lineRippleFoundation.activate();\n                }\n            }, deactivateBottomLine: () => {\n                if (this.lineRippleElement) {\n                    this.lineRippleElement.lineRippleFoundation.deactivate();\n                }\n            }, hasLabel: () => {\n                return !!this.label;\n            }, floatLabel: (shouldFloat) => {\n                if (this.labelElement) {\n                    this.labelElement.floatingLabelFoundation.float(shouldFloat);\n                }\n            }, getLabelWidth: () => {\n                if (this.labelElement) {\n                    return this.labelElement.floatingLabelFoundation.getWidth();\n                }\n                return 0;\n            }, setLabelRequired: (isRequired) => {\n                if (this.labelElement) {\n                    this.labelElement.floatingLabelFoundation.setRequired(isRequired);\n                }\n            }, hasOutline: () => this.outlined, notchOutline: (labelWidth) => {\n                const outlineElement = this.outlineElement;\n                if (outlineElement && !this.outlineOpen) {\n                    this.outlineWidth = labelWidth;\n                    this.outlineOpen = true;\n                }\n            }, closeOutline: () => {\n                if (this.outlineElement) {\n                    this.outlineOpen = false;\n                }\n            }, setRippleCenter: (normalizedX) => {\n                if (this.lineRippleElement) {\n                    const foundation = this.lineRippleElement.lineRippleFoundation;\n                    foundation.setRippleCenter(normalizedX);\n                }\n            }, notifyChange: async (value) => {\n                if (!this.valueSetDirectly && value === this.value) {\n                    return;\n                }\n                this.valueSetDirectly = false;\n                this.value = value;\n                await this.updateComplete;\n                const ev = new Event('change', { bubbles: true });\n                this.dispatchEvent(ev);\n            }, setSelectedText: (value) => this.selectedText = value, isSelectAnchorFocused: () => {\n                const selectAnchorElement = this.anchorElement;\n                if (!selectAnchorElement) {\n                    return false;\n                }\n                const rootNode = selectAnchorElement.getRootNode();\n                return rootNode.activeElement === selectAnchorElement;\n            }, getSelectAnchorAttr: (attr) => {\n                const selectAnchorElement = this.anchorElement;\n                if (!selectAnchorElement) {\n                    return null;\n                }\n                return selectAnchorElement.getAttribute(attr);\n            }, setSelectAnchorAttr: (attr, value) => {\n                const selectAnchorElement = this.anchorElement;\n                if (!selectAnchorElement) {\n                    return;\n                }\n                selectAnchorElement.setAttribute(attr, value);\n            }, removeSelectAnchorAttr: (attr) => {\n                const selectAnchorElement = this.anchorElement;\n                if (!selectAnchorElement) {\n                    return;\n                }\n                selectAnchorElement.removeAttribute(attr);\n            }, openMenu: () => {\n                this.menuOpen = true;\n            }, closeMenu: () => {\n                this.menuOpen = false;\n            }, addMenuClass: () => undefined, removeMenuClass: () => undefined, getAnchorElement: () => this.anchorElement, setMenuAnchorElement: () => {\n                /* Handled by anchor directive */\n            }, setMenuAnchorCorner: () => {\n                const menuElement = this.menuElement;\n                if (menuElement) {\n                    menuElement.corner = 'BOTTOM_START';\n                }\n            }, setMenuWrapFocus: (wrapFocus) => {\n                const menuElement = this.menuElement;\n                if (menuElement) {\n                    menuElement.wrapFocus = wrapFocus;\n                }\n            }, focusMenuItemAtIndex: (index) => {\n                const menuElement = this.menuElement;\n                if (!menuElement) {\n                    return;\n                }\n                const element = menuElement.items[index];\n                if (!element) {\n                    return;\n                }\n                element.focus();\n            }, getMenuItemCount: () => {\n                const menuElement = this.menuElement;\n                if (menuElement) {\n                    return menuElement.items.length;\n                }\n                return 0;\n            }, getMenuItemValues: () => {\n                const menuElement = this.menuElement;\n                if (!menuElement) {\n                    return [];\n                }\n                const items = menuElement.items;\n                return items.map((item) => item.value);\n            }, getMenuItemTextAtIndex: (index) => {\n                const menuElement = this.menuElement;\n                if (!menuElement) {\n                    return '';\n                }\n                const element = menuElement.items[index];\n                if (!element) {\n                    return '';\n                }\n                return element.text;\n            }, getSelectedIndex: () => this.index, setSelectedIndex: () => undefined, isTypeaheadInProgress: () => typeahead.isTypingInProgress(this.typeaheadState), typeaheadMatchItem: (nextChar, startingIndex) => {\n                if (!this.menuElement) {\n                    return -1;\n                }\n                const opts = {\n                    focusItemAtIndex: (index) => {\n                        this.menuElement.focusItemAtIndex(index);\n                    },\n                    focusedItemIndex: startingIndex ?\n                        startingIndex :\n                        this.menuElement.getFocusedItemIndex(),\n                    nextChar,\n                    sortedIndexByFirstChar: this.sortedIndexByFirstChar,\n                    skipFocus: false,\n                    isItemAtIndexDisabled: (index) => this.items[index].disabled,\n                };\n                const index = typeahead.matchItem(opts, this.typeaheadState);\n                if (index !== -1) {\n                    this.select(index);\n                }\n                return index;\n            } });\n    }\n    checkValidity() {\n        const isValid = this._checkValidity(this.value);\n        if (!isValid) {\n            const invalidEvent = new Event('invalid', { bubbles: false, cancelable: true });\n            this.dispatchEvent(invalidEvent);\n        }\n        return isValid;\n    }\n    reportValidity() {\n        const isValid = this.checkValidity();\n        this.isUiValid = isValid;\n        return isValid;\n    }\n    _checkValidity(value) {\n        const nativeValidity = this.formElement.validity;\n        let validity = createValidityObj(nativeValidity);\n        if (this.validityTransform) {\n            const customValidity = this.validityTransform(value, validity);\n            validity = Object.assign(Object.assign({}, validity), customValidity);\n        }\n        this._validity = validity;\n        return this._validity.valid;\n    }\n    setCustomValidity(message) {\n        this.validationMessage = message;\n        this.formElement.setCustomValidity(message);\n    }\n    // tslint:disable:ban-ts-ignore\n    async getUpdateComplete() {\n        await this._menuUpdateComplete;\n        // @ts-ignore\n        const result = await super.getUpdateComplete();\n        return result;\n    }\n    // tslint:enable:ban-ts-ignore\n    async firstUpdated() {\n        const menuElement = this.menuElement;\n        if (menuElement) {\n            this._menuUpdateComplete = menuElement.updateComplete;\n            await this._menuUpdateComplete;\n        }\n        super.firstUpdated();\n        this.mdcFoundation.isValid = () => true;\n        this.mdcFoundation.setValid = () => undefined;\n        this.mdcFoundation.setDisabled(this.disabled);\n        if (this.validateOnInitialRender) {\n            this.reportValidity();\n        }\n        // Select an option based on init value\n        if (!this.selected) {\n            if (!this.items.length && this.slotElement &&\n                this.slotElement.assignedNodes({ flatten: true }).length) {\n                // Shady DOM initial render fix\n                await new Promise((res) => requestAnimationFrame(res));\n                await this.layout();\n            }\n            const hasEmptyFirstOption = this.items.length && this.items[0].value === '';\n            if (!this.value && hasEmptyFirstOption) {\n                this.select(0);\n                return;\n            }\n            this.selectByValue(this.value);\n        }\n        this.sortedIndexByFirstChar = typeahead.initSortedIndex(this.items.length, (index) => this.items[index].text);\n    }\n    onItemsUpdated() {\n        this.sortedIndexByFirstChar = typeahead.initSortedIndex(this.items.length, (index) => this.items[index].text);\n    }\n    select(index) {\n        const menuElement = this.menuElement;\n        if (menuElement) {\n            menuElement.select(index);\n        }\n    }\n    selectByValue(value) {\n        let indexToSelect = -1;\n        for (let i = 0; i < this.items.length; i++) {\n            const item = this.items[i];\n            if (item.value === value) {\n                indexToSelect = i;\n                break;\n            }\n        }\n        this.valueSetDirectly = true;\n        this.select(indexToSelect);\n        this.mdcFoundation.handleChange();\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        for (const listener of this.listeners) {\n            listener.target.removeEventListener(listener.name, listener.cb);\n        }\n    }\n    focus() {\n        const focusEvt = new CustomEvent('focus');\n        const selectAnchorElement = this.anchorElement;\n        if (selectAnchorElement) {\n            selectAnchorElement.dispatchEvent(focusEvt);\n            selectAnchorElement.focus();\n        }\n    }\n    blur() {\n        const focusEvt = new CustomEvent('blur');\n        const selectAnchorElement = this.anchorElement;\n        if (selectAnchorElement) {\n            selectAnchorElement.dispatchEvent(focusEvt);\n            selectAnchorElement.blur();\n        }\n    }\n    onFocus() {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.handleFocus();\n        }\n    }\n    onBlur() {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.handleBlur();\n        }\n        const menuElement = this.menuElement;\n        if (menuElement && !menuElement.open) {\n            this.reportValidity();\n        }\n    }\n    onClick(evt) {\n        if (this.mdcFoundation) {\n            this.focus();\n            const targetClientRect = evt.target.getBoundingClientRect();\n            let xCoord = 0;\n            if ('touches' in evt) {\n                xCoord = evt.touches[0].clientX;\n            }\n            else {\n                xCoord = evt.clientX;\n            }\n            const normalizedX = xCoord - targetClientRect.left;\n            this.mdcFoundation.handleClick(normalizedX);\n        }\n    }\n    onKeydown(evt) {\n        const arrowUp = normalizeKey(evt) === KEY.ARROW_UP;\n        const arrowDown = normalizeKey(evt) === KEY.ARROW_DOWN;\n        if (arrowDown || arrowUp) {\n            const shouldSelectNextItem = arrowUp && this.index > 0;\n            const shouldSelectPrevItem = arrowDown && this.index < this.items.length - 1;\n            if (shouldSelectNextItem) {\n                this.select(this.index - 1);\n            }\n            else if (shouldSelectPrevItem) {\n                this.select(this.index + 1);\n            }\n            evt.preventDefault();\n            this.mdcFoundation.openMenu();\n            return;\n        }\n        this.mdcFoundation.handleKeydown(evt);\n    }\n    // must capture to run before list foundation captures event\n    handleTypeahead(event) {\n        if (!this.menuElement) {\n            return;\n        }\n        const focusedItemIndex = this.menuElement.getFocusedItemIndex();\n        const target = isNodeElement(event.target) ?\n            event.target :\n            null;\n        const isTargetListItem = target ? target.hasAttribute('mwc-list-item') : false;\n        const opts = {\n            event,\n            focusItemAtIndex: (index) => {\n                this.menuElement.focusItemAtIndex(index);\n            },\n            focusedItemIndex,\n            isTargetListItem,\n            sortedIndexByFirstChar: this.sortedIndexByFirstChar,\n            isItemAtIndexDisabled: (index) => this.items[index].disabled,\n        };\n        typeahead.handleKeydown(opts, this.typeaheadState);\n    }\n    async onSelected(event) {\n        if (!this.mdcFoundation) {\n            await this.updateComplete;\n        }\n        this.mdcFoundation.handleMenuItemAction(event.detail.index);\n        const item = this.items[event.detail.index];\n        if (item) {\n            this.value = item.value;\n        }\n    }\n    onOpened() {\n        if (this.mdcFoundation) {\n            this.menuOpen = true;\n            this.mdcFoundation.handleMenuOpened();\n        }\n    }\n    onClosed() {\n        if (this.mdcFoundation) {\n            this.menuOpen = false;\n            this.mdcFoundation.handleMenuClosed();\n        }\n    }\n    setFormData(formData) {\n        if (this.name && this.selected !== null) {\n            formData.append(this.name, this.value);\n        }\n    }\n    async layout(updateItems = true) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.layout();\n        }\n        await this.updateComplete;\n        const menuElement = this.menuElement;\n        if (menuElement) {\n            menuElement.layout(updateItems);\n        }\n        const labelElement = this.labelElement;\n        if (!labelElement) {\n            this.outlineOpen = false;\n            return;\n        }\n        const shouldFloat = !!this.label && !!this.value;\n        labelElement.floatingLabelFoundation.float(shouldFloat);\n        if (!this.outlined) {\n            return;\n        }\n        this.outlineOpen = shouldFloat;\n        await this.updateComplete;\n        /* When the textfield automatically notches due to a value and label\n         * being defined, the textfield may be set to `display: none` by the user.\n         * this means that the notch is of size 0px. We provide this function so\n         * that the user may manually resize the notch to the floated label's\n         * width.\n         */\n        const labelWidth = labelElement.floatingLabelFoundation.getWidth();\n        if (this.outlineOpen) {\n            this.outlineWidth = labelWidth;\n        }\n    }\n    async layoutOptions() {\n        if (!this.mdcFoundation) {\n            return;\n        }\n        this.mdcFoundation.layoutOptions();\n    }\n}\n__decorate([\n    query('.mdc-select')\n], SelectBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('.formElement')\n], SelectBase.prototype, \"formElement\", void 0);\n__decorate([\n    query('slot')\n], SelectBase.prototype, \"slotElement\", void 0);\n__decorate([\n    query('select')\n], SelectBase.prototype, \"nativeSelectElement\", void 0);\n__decorate([\n    query('input')\n], SelectBase.prototype, \"nativeInputElement\", void 0);\n__decorate([\n    query('.mdc-line-ripple')\n], SelectBase.prototype, \"lineRippleElement\", void 0);\n__decorate([\n    query('.mdc-floating-label')\n], SelectBase.prototype, \"labelElement\", void 0);\n__decorate([\n    query('mwc-notched-outline')\n], SelectBase.prototype, \"outlineElement\", void 0);\n__decorate([\n    query('.mdc-menu')\n], SelectBase.prototype, \"menuElement\", void 0);\n__decorate([\n    query('.mdc-select__anchor')\n], SelectBase.prototype, \"anchorElement\", void 0);\n__decorate([\n    property({ type: Boolean, attribute: 'disabled', reflect: true }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.setDisabled(value);\n        }\n    })\n], SelectBase.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (_newVal, oldVal) {\n        if (oldVal !== undefined && this.outlined !== oldVal) {\n            this.layout(false);\n        }\n    })\n], SelectBase.prototype, \"outlined\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (_newVal, oldVal) {\n        if (oldVal !== undefined && this.label !== oldVal) {\n            this.layout(false);\n        }\n    })\n], SelectBase.prototype, \"label\", void 0);\n__decorate([\n    state()\n], SelectBase.prototype, \"outlineOpen\", void 0);\n__decorate([\n    state()\n], SelectBase.prototype, \"outlineWidth\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            const initialization = this.selected === null && !!value;\n            const valueSetByUser = this.selected && this.selected.value !== value;\n            if (initialization || valueSetByUser) {\n                this.selectByValue(value);\n            }\n            this.reportValidity();\n        }\n    })\n], SelectBase.prototype, \"value\", void 0);\n__decorate([\n    property()\n], SelectBase.prototype, \"name\", void 0);\n__decorate([\n    state()\n], SelectBase.prototype, \"selectedText\", void 0);\n__decorate([\n    property({ type: String })\n], SelectBase.prototype, \"icon\", void 0);\n__decorate([\n    state()\n], SelectBase.prototype, \"menuOpen\", void 0);\n__decorate([\n    property({ type: String })\n], SelectBase.prototype, \"helper\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SelectBase.prototype, \"validateOnInitialRender\", void 0);\n__decorate([\n    property({ type: String })\n], SelectBase.prototype, \"validationMessage\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SelectBase.prototype, \"required\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SelectBase.prototype, \"naturalMenuWidth\", void 0);\n__decorate([\n    state()\n], SelectBase.prototype, \"isUiValid\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SelectBase.prototype, \"fixedMenuPosition\", void 0);\n__decorate([\n    eventOptions({ capture: true })\n], SelectBase.prototype, \"handleTypeahead\", null);\n//# sourceMappingURL=mwc-select-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-ripple/mwc-ripple';\nimport { ariaProperty } from '@material/mwc-base/aria-property';\nimport { FormElement } from '@material/mwc-base/form-element';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers';\nimport { MDCSliderFoundation } from '@material/slider/foundation';\nimport { Thumb, TickMark } from '@material/slider/types';\nimport { html, nothing } from 'lit';\nimport { property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { styleMap } from 'lit/directives/style-map.js';\nexport { Thumb } from '@material/slider/types';\nexport class SliderBase extends FormElement {\n    constructor() {\n        super(...arguments);\n        this.mdcFoundationClass = MDCSliderFoundation;\n        this.disabled = false;\n        this.min = 0;\n        this.max = 100;\n        this.valueEnd = 0;\n        this.name = '';\n        this.step = 1;\n        this.withTickMarks = false;\n        this.discrete = false;\n        this.tickMarks = [];\n        this.trackTransformOriginStyle = '';\n        this.trackLeftStyle = '';\n        this.trackRightStyle = '';\n        this.trackTransitionStyle = '';\n        this.endThumbWithIndicator = false;\n        this.endThumbTop = false;\n        this.shouldRenderEndRipple = false;\n        this.endThumbTransformStyle = '';\n        this.endThumbTransitionStyle = '';\n        this.valueToAriaTextTransform = null;\n        this.valueToValueIndicatorTransform = (value) => {\n            return `${value}`;\n        };\n        this.boundMoveListener = null;\n        this.endRippleHandlers = new RippleHandlers(() => {\n            this.shouldRenderEndRipple = true;\n            return this.endRipple;\n        });\n    }\n    update(changed) {\n        if (changed.has('valueEnd') && this.mdcFoundation) {\n            this.mdcFoundation.setValue(this.valueEnd);\n            const validVal = this.mdcFoundation.getValue();\n            if (validVal !== this.valueEnd) {\n                this.valueEnd = validVal;\n            }\n        }\n        if (changed.has('discrete')) {\n            if (!this.discrete) {\n                this.tickMarks = [];\n            }\n        }\n        super.update(changed);\n    }\n    render() {\n        return this.renderRootEl(html `\n      ${this.renderStartInput()}\n      ${this.renderEndInput()}\n      ${this.renderTrack()}\n      ${this.renderTickMarks()}\n      ${this.renderStartThumb()}\n      ${this.renderEndThumb()}`);\n    }\n    renderRootEl(content) {\n        const rootClasses = classMap({\n            'mdc-slider--disabled': this.disabled,\n            'mdc-slider--discrete': this.discrete,\n        });\n        return html `\n    <div\n        class=\"mdc-slider ${rootClasses}\"\n        @pointerdown=${this.onPointerdown}\n        @pointerup=${this.onPointerup}\n        @contextmenu=${this.onContextmenu}>\n      ${content}\n    </div>`;\n    }\n    renderStartInput() {\n        return nothing;\n    }\n    renderEndInput() {\n        var _a;\n        return html `\n      <input\n          class=\"mdc-slider__input end\"\n          type=\"range\"\n          step=${this.step}\n          min=${this.min}\n          max=${this.max}\n          .value=${this.valueEnd}\n          @change=${this.onEndChange}\n          @focus=${this.onEndFocus}\n          @blur=${this.onEndBlur}\n          ?disabled=${this.disabled}\n          name=${this.name}\n          aria-label=${ifDefined(this.ariaLabel)}\n          aria-labelledby=${ifDefined(this.ariaLabelledBy)}\n          aria-describedby=${ifDefined(this.ariaDescribedBy)}\n          aria-valuetext=${ifDefined((_a = this.valueToAriaTextTransform) === null || _a === void 0 ? void 0 : _a.call(this, this.valueEnd))}>\n    `;\n    }\n    renderTrack() {\n        return nothing;\n    }\n    renderTickMarks() {\n        return !this.withTickMarks ? nothing : html `\n      <div class=\"mdc-slider__tick-marks\">\n        ${this.tickMarks.map((tickMark) => {\n            const isActive = tickMark === TickMark.ACTIVE;\n            return html `<div class=\"${isActive ? 'mdc-slider__tick-mark--active' :\n                'mdc-slider__tick-mark--inactive'}\"></div>`;\n        })}\n      </div>`;\n    }\n    renderStartThumb() {\n        return nothing;\n    }\n    renderEndThumb() {\n        const endThumbClasses = classMap({\n            'mdc-slider__thumb--with-indicator': this.endThumbWithIndicator,\n            'mdc-slider__thumb--top': this.endThumbTop,\n        });\n        const endThumbStyles = styleMap({\n            '-webkit-transform': this.endThumbTransformStyle,\n            'transform': this.endThumbTransformStyle,\n            '-webkit-transition': this.endThumbTransitionStyle,\n            'transition': this.endThumbTransitionStyle,\n            'left': this.endThumbTransformStyle ?\n                '' :\n                getComputedStyle(this).direction === 'rtl' ?\n                    '' :\n                    `calc(${(this.valueEnd - this.min) / (this.max - this.min) *\n                        100}% - 24px)`,\n            'right': this.endThumbTransformStyle ?\n                '' :\n                getComputedStyle(this).direction !== 'rtl' ?\n                    '' :\n                    `calc(${(this.valueEnd - this.min) / (this.max - this.min) *\n                        100}% - 24px)`,\n        });\n        const ripple = !this.shouldRenderEndRipple ?\n            nothing :\n            html `<mwc-ripple class=\"ripple\" unbounded></mwc-ripple>`;\n        return html `\n      <div\n          class=\"mdc-slider__thumb end ${endThumbClasses}\"\n          style=${endThumbStyles}\n          @mouseenter=${this.onEndMouseenter}\n          @mouseleave=${this.onEndMouseleave}>\n        ${ripple}\n        ${this.renderValueIndicator(this.valueToValueIndicatorTransform(this.valueEnd))}\n        <div class=\"mdc-slider__thumb-knob\"></div>\n      </div>\n    `;\n    }\n    renderValueIndicator(text) {\n        return this.discrete ? html `\n    <div class=\"mdc-slider__value-indicator-container\" aria-hidden=\"true\">\n      <div class=\"mdc-slider__value-indicator\">\n        <span class=\"mdc-slider__value-indicator-text\">\n          ${text}\n        </span>\n      </div>\n    </div>` :\n            nothing;\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        if (this.mdcFoundation) {\n            this.mdcFoundation.destroy();\n        }\n    }\n    createAdapter() { }\n    async firstUpdated() {\n        super.firstUpdated();\n        await this.layout(true);\n    }\n    updated(changed) {\n        super.updated(changed);\n        if (!this.mdcFoundation) {\n            return;\n        }\n        if (changed.has('disabled')) {\n            this.mdcFoundation.setDisabled(this.disabled);\n        }\n        if (changed.has('min')) {\n            this.mdcFoundation.setMin(this.min);\n        }\n        if (changed.has('max')) {\n            this.mdcFoundation.setMax(this.max);\n        }\n        if (changed.has('step')) {\n            this.mdcFoundation.setStep(this.step);\n        }\n        if (changed.has('discrete')) {\n            this.mdcFoundation.setIsDiscrete(this.discrete);\n        }\n        if (changed.has('withTickMarks')) {\n            this.mdcFoundation.setHasTickMarks(this.withTickMarks);\n        }\n    }\n    async layout(skipUpdateUI = false) {\n        var _a;\n        (_a = this.mdcFoundation) === null || _a === void 0 ? void 0 : _a.layout({ skipUpdateUI });\n        this.requestUpdate();\n        await this.updateComplete;\n    }\n    onEndChange(e) {\n        var _a;\n        this.valueEnd = Number(e.target.value);\n        (_a = this.mdcFoundation) === null || _a === void 0 ? void 0 : _a.handleInputChange(Thumb.END);\n    }\n    onEndFocus() {\n        var _a;\n        (_a = this.mdcFoundation) === null || _a === void 0 ? void 0 : _a.handleInputFocus(Thumb.END);\n        this.endRippleHandlers.startFocus();\n    }\n    onEndBlur() {\n        var _a;\n        (_a = this.mdcFoundation) === null || _a === void 0 ? void 0 : _a.handleInputBlur(Thumb.END);\n        this.endRippleHandlers.endFocus();\n    }\n    onEndMouseenter() {\n        var _a;\n        (_a = this.mdcFoundation) === null || _a === void 0 ? void 0 : _a.handleThumbMouseenter();\n        this.endRippleHandlers.startHover();\n    }\n    onEndMouseleave() {\n        var _a;\n        (_a = this.mdcFoundation) === null || _a === void 0 ? void 0 : _a.handleThumbMouseleave();\n        this.endRippleHandlers.endHover();\n    }\n    onPointerdown(e) {\n        this.layout();\n        if (this.mdcFoundation) {\n            this.mdcFoundation.handlePointerdown(e);\n            this.boundMoveListener =\n                this.mdcFoundation.handleMove.bind(this.mdcFoundation);\n            this.mdcRoot.addEventListener('pointermove', this.boundMoveListener);\n        }\n    }\n    onPointerup() {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.handleUp();\n            if (this.boundMoveListener) {\n                this.mdcRoot.removeEventListener('pointermove', this.boundMoveListener);\n                this.boundMoveListener = null;\n            }\n        }\n    }\n    onContextmenu(e) {\n        // prevents context menu otherwise pointerdown will fire but not pointerup\n        e.preventDefault();\n    }\n    setFormData(formData) {\n        if (this.name) {\n            formData.append(this.name, `${this.valueEnd}`);\n        }\n    }\n}\n__decorate([\n    query('input.end')\n], SliderBase.prototype, \"formElement\", void 0);\n__decorate([\n    query('.mdc-slider')\n], SliderBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('.end.mdc-slider__thumb')\n], SliderBase.prototype, \"endThumb\", void 0);\n__decorate([\n    query('.end.mdc-slider__thumb .mdc-slider__thumb-knob')\n], SliderBase.prototype, \"endThumbKnob\", void 0);\n__decorate([\n    queryAsync('.end .ripple')\n], SliderBase.prototype, \"endRipple\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], SliderBase.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Number })\n], SliderBase.prototype, \"min\", void 0);\n__decorate([\n    property({ type: Number })\n], SliderBase.prototype, \"max\", void 0);\n__decorate([\n    property({ type: Number })\n], SliderBase.prototype, \"valueEnd\", void 0);\n__decorate([\n    property({ type: String })\n], SliderBase.prototype, \"name\", void 0);\n__decorate([\n    property({ type: Number })\n], SliderBase.prototype, \"step\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SliderBase.prototype, \"withTickMarks\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SliderBase.prototype, \"discrete\", void 0);\n__decorate([\n    state()\n], SliderBase.prototype, \"tickMarks\", void 0);\n__decorate([\n    state()\n], SliderBase.prototype, \"trackTransformOriginStyle\", void 0);\n__decorate([\n    state()\n], SliderBase.prototype, \"trackLeftStyle\", void 0);\n__decorate([\n    state()\n], SliderBase.prototype, \"trackRightStyle\", void 0);\n__decorate([\n    state()\n], SliderBase.prototype, \"trackTransitionStyle\", void 0);\n__decorate([\n    state()\n], SliderBase.prototype, \"endThumbWithIndicator\", void 0);\n__decorate([\n    state()\n], SliderBase.prototype, \"endThumbTop\", void 0);\n__decorate([\n    state()\n], SliderBase.prototype, \"shouldRenderEndRipple\", void 0);\n__decorate([\n    state()\n], SliderBase.prototype, \"endThumbTransformStyle\", void 0);\n__decorate([\n    state()\n], SliderBase.prototype, \"endThumbTransitionStyle\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-label' })\n], SliderBase.prototype, \"ariaLabel\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-labelledby' })\n], SliderBase.prototype, \"ariaLabelledBy\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-describedby' })\n], SliderBase.prototype, \"ariaDescribedBy\", void 0);\n//# sourceMappingURL=slider-base.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-ripple/mwc-ripple';\nimport { deepActiveElementPath } from '@material/mwc-base/utils';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers';\nimport { Thumb } from '@material/slider/types';\nimport { html, nothing } from 'lit';\nimport { property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { styleMap } from 'lit/directives/style-map.js';\nimport { SliderBase } from './slider-base';\nexport { Thumb } from '@material/slider/types';\nexport class SliderRangeBase extends SliderBase {\n    constructor() {\n        super(...arguments);\n        this.valueStart = 0;\n        this.startThumbWithIndicator = false;\n        this.startThumbTop = false;\n        this.shouldRenderStartRipple = false;\n        this.startThumbTransformStyle = '';\n        this.startThumbTransitionStyle = '';\n        this.startRippleHandlers = new RippleHandlers(() => {\n            this.shouldRenderStartRipple = true;\n            return this.startRipple;\n        });\n    }\n    update(changed) {\n        if (changed.has('valueStart') && this.mdcFoundation) {\n            this.mdcFoundation.setValueStart(this.valueStart);\n            const validVal = this.mdcFoundation.getValueStart();\n            if (validVal !== this.valueStart) {\n                this.valueStart = validVal;\n            }\n        }\n        super.update(changed);\n    }\n    renderRootEl(content) {\n        const rootClasses = classMap({\n            'mdc-slider--disabled': this.disabled,\n            'mdc-slider--discrete': this.discrete,\n        });\n        return html `\n    <div\n        class=\"mdc-slider mdc-slider--range ${rootClasses}\"\n        @pointerdown=${this.onPointerdown}\n        @pointerup=${this.onPointerup}\n        @contextmenu=${this.onContextmenu}>\n      ${content}\n    </div>`;\n    }\n    renderStartInput() {\n        var _a;\n        return html `\n      <input\n          class=\"mdc-slider__input start\"\n          type=\"range\"\n          step=${this.step}\n          min=${this.min}\n          max=${this.valueEnd}\n          .value=${this.valueStart}\n          @change=${this.onStartChange}\n          @focus=${this.onStartFocus}\n          @blur=${this.onStartBlur}\n          ?disabled=${this.disabled}\n          aria-label=${ifDefined(this.ariaLabel)}\n          aria-labelledby=${ifDefined(this.ariaLabelledBy)}\n          aria-describedby=${ifDefined(this.ariaDescribedBy)}\n          aria-valuetext=${ifDefined((_a = this.valueToAriaTextTransform) === null || _a === void 0 ? void 0 : _a.call(this, this.valueStart))}>\n    `;\n    }\n    renderEndInput() {\n        var _a;\n        return html `\n      <input\n          class=\"mdc-slider__input end\"\n          type=\"range\"\n          step=${this.step}\n          min=${this.valueStart}\n          max=${this.max}\n          .value=${this.valueEnd}\n          @change=${this.onEndChange.bind(this)}\n          @focus=${this.onEndFocus}\n          @blur=${this.onEndBlur}\n          ?disabled=${this.disabled}\n          name=${this.name}\n          aria-label=${ifDefined(this.ariaLabel)}\n          aria-labelledby=${ifDefined(this.ariaLabelledBy)}\n          aria-describedby=${ifDefined(this.ariaDescribedBy)}\n          aria-valuetext=${ifDefined((_a = this.valueToAriaTextTransform) === null || _a === void 0 ? void 0 : _a.call(this, this.valueEnd))}>\n    `;\n    }\n    renderTrack() {\n        const trackStyles = styleMap({\n            'transform-origin': this.trackTransformOriginStyle,\n            'left': this.trackLeftStyle ?\n                this.trackLeftStyle :\n                getComputedStyle(this).direction === 'rtl' ?\n                    '' :\n                    `calc(${(this.valueStart - this.min) / (this.max - this.min) * 100}%)`,\n            'right': this.trackRightStyle ?\n                this.trackRightStyle :\n                getComputedStyle(this).direction !== 'rtl' ?\n                    '' :\n                    `calc(${(this.valueStart - this.min) / (this.max - this.min) * 100}%)`,\n            '-webkit-transform': `scaleX(${(this.valueEnd - this.valueStart) / (this.max - this.min)})`,\n            'transform': `scaleX(${(this.valueEnd - this.valueStart) / (this.max - this.min)})`,\n            '-webkit-transition': this.trackTransitionStyle,\n            'transition': this.trackTransitionStyle,\n        });\n        return html `\n      <div class=\"mdc-slider__track\">\n        <div class=\"mdc-slider__track--inactive\"></div>\n        <div class=\"mdc-slider__track--active\">\n          <div\n              class=\"mdc-slider__track--active_fill\"\n              style=${trackStyles}>\n          </div>\n        </div>\n      </div>`;\n    }\n    renderStartThumb() {\n        const startThumbClasses = classMap({\n            'mdc-slider__thumb--with-indicator': this.startThumbWithIndicator,\n            'mdc-slider__thumb--top': this.startThumbTop,\n        });\n        const startThumbStyles = styleMap({\n            '-webkit-transform': this.startThumbTransformStyle,\n            'transform': this.startThumbTransformStyle,\n            '-webkit-transition': this.startThumbTransitionStyle,\n            'transition': this.startThumbTransitionStyle,\n            'left': this.startThumbTransformStyle ?\n                '' :\n                getComputedStyle(this).direction === 'rtl' ?\n                    '' :\n                    `calc(${(this.valueStart - this.min) / (this.max - this.min) *\n                        100}% - 24px)`,\n            'right': this.startThumbTransformStyle ?\n                '' :\n                getComputedStyle(this).direction !== 'rtl' ?\n                    '' :\n                    `calc(${(this.valueStart - this.min) / (this.max - this.min) *\n                        100}% - 24px)`,\n        });\n        const ripple = !this.shouldRenderStartRipple ?\n            nothing :\n            html `<mwc-ripple class=\"ripple\" unbounded></mwc-ripple>`;\n        return html `\n      <div\n          class=\"mdc-slider__thumb start ${startThumbClasses}\"\n          style=${startThumbStyles}\n          @mouseenter=${this.onStartMouseenter}\n          @mouseleave=${this.onStartMouseleave}>\n        ${ripple}\n        ${this.renderValueIndicator(this.valueToValueIndicatorTransform(this.valueStart))}\n        <div class=\"mdc-slider__thumb-knob\"></div>\n      </div>\n    `;\n    }\n    createAdapter() {\n        return {\n            addClass: (className) => {\n                switch (className) {\n                    case 'mdc-slider--disabled':\n                        this.disabled = true;\n                        break;\n                }\n            },\n            removeClass: (className) => {\n                switch (className) {\n                    case 'mdc-slider--disabled':\n                        this.disabled = false;\n                        break;\n                }\n            },\n            hasClass: (className) => {\n                switch (className) {\n                    case 'mdc-slider--disabled':\n                        return this.disabled;\n                    case 'mdc-slider--range':\n                        return true;\n                    case 'mdc-slider--discrete':\n                        return this.discrete;\n                    default:\n                        return false;\n                }\n            },\n            addThumbClass: (className, thumb) => {\n                if (thumb === Thumb.START) {\n                    switch (className) {\n                        case 'mdc-slider__thumb--with-indicator':\n                            this.startThumbWithIndicator = true;\n                            break;\n                        case 'mdc-slider__thumb--top':\n                            this.startThumbTop = true;\n                            break;\n                    }\n                }\n                else {\n                    switch (className) {\n                        case 'mdc-slider__thumb--with-indicator':\n                            this.endThumbWithIndicator = true;\n                            break;\n                        case 'mdc-slider__thumb--top':\n                            this.endThumbTop = true;\n                            break;\n                    }\n                }\n            },\n            removeThumbClass: (className, thumb) => {\n                if (thumb === Thumb.START) {\n                    switch (className) {\n                        case 'mdc-slider__thumb--with-indicator':\n                            this.startThumbWithIndicator = false;\n                            break;\n                        case 'mdc-slider__thumb--top':\n                            this.startThumbTop = false;\n                            break;\n                    }\n                }\n                else {\n                    switch (className) {\n                        case 'mdc-slider__thumb--with-indicator':\n                            this.endThumbWithIndicator = false;\n                            break;\n                        case 'mdc-slider__thumb--top':\n                            this.endThumbTop = false;\n                            break;\n                    }\n                }\n            },\n            registerEventHandler: () => {\n                // handled in bindings\n            },\n            deregisterEventHandler: () => {\n                // handled in bindings\n            },\n            registerBodyEventHandler: (eventName, handler) => {\n                document.body.addEventListener(eventName, handler);\n            },\n            deregisterBodyEventHandler: (eventName, handler) => {\n                document.body.removeEventListener(eventName, handler);\n            },\n            registerInputEventHandler: (thumb, eventName, handler) => {\n                if (thumb === Thumb.START) {\n                    this.startInput.addEventListener(eventName, handler);\n                }\n                else {\n                    this.formElement.addEventListener(eventName, handler);\n                }\n            },\n            deregisterInputEventHandler: (thumb, eventName, handler) => {\n                if (thumb === Thumb.START) {\n                    this.startInput.removeEventListener(eventName, handler);\n                }\n                else {\n                    this.formElement.removeEventListener(eventName, handler);\n                }\n            },\n            registerThumbEventHandler: () => {\n                // handled by bindings\n            },\n            deregisterThumbEventHandler: () => {\n                // handled by bindings\n            },\n            registerWindowEventHandler: (eventName, handler) => {\n                window.addEventListener(eventName, handler);\n            },\n            deregisterWindowEventHandler: (eventName, handler) => {\n                window.removeEventListener(eventName, handler);\n            },\n            emitChangeEvent: (value, thumb) => {\n                const event = new CustomEvent('change', { bubbles: true, composed: true, detail: { value, thumb } });\n                this.dispatchEvent(event);\n            },\n            emitDragEndEvent: (_value, thumb) => {\n                // Emitting event is not yet implemented. See issue:\n                // https://github.com/material-components/material-components-web/issues/6448\n                if (thumb === Thumb.START) {\n                    this.startRippleHandlers.endPress();\n                }\n                else {\n                    this.endRippleHandlers.endPress();\n                }\n            },\n            emitDragStartEvent: (_value, thumb) => {\n                // Emitting event is not yet implemented. See issue:\n                // https://github.com/material-components/material-components-web/issues/6448\n                if (thumb === Thumb.START) {\n                    this.startRippleHandlers.startPress();\n                }\n                else {\n                    this.endRippleHandlers.startPress();\n                }\n            },\n            emitInputEvent: (value, thumb) => {\n                const event = new CustomEvent('input', { bubbles: true, composed: true, detail: { value, thumb } });\n                this.dispatchEvent(event);\n            },\n            focusInput: (thumb) => {\n                if (thumb === Thumb.START) {\n                    this.startInput.focus();\n                }\n                else {\n                    this.formElement.focus();\n                }\n            },\n            getAttribute: () => {\n                // never seems to actually be used\n                return '';\n            },\n            getBoundingClientRect: () => {\n                return this.mdcRoot.getBoundingClientRect();\n            },\n            getInputAttribute: (attrName, thumb) => {\n                if (thumb === Thumb.START) {\n                    switch (attrName) {\n                        case 'min':\n                            return this.min.toString();\n                        case 'max':\n                            return this.valueEnd.toString();\n                        case 'value':\n                            return this.valueStart.toString();\n                        case 'step':\n                            return this.step.toString();\n                        default:\n                            return null;\n                    }\n                }\n                switch (attrName) {\n                    case 'min':\n                        return this.valueStart.toString();\n                    case 'max':\n                        return this.max.toString();\n                    case 'value':\n                        return this.valueEnd.toString();\n                    case 'step':\n                        return this.step.toString();\n                    default:\n                        return null;\n                }\n            },\n            getInputValue: (thumb) => {\n                if (thumb === Thumb.START) {\n                    return this.valueStart.toString();\n                }\n                return this.valueEnd.toString();\n            },\n            getThumbBoundingClientRect: (thumb) => {\n                if (thumb === Thumb.START) {\n                    return this.startThumb.getBoundingClientRect();\n                }\n                return this.endThumb.getBoundingClientRect();\n            },\n            getThumbKnobWidth: (thumb) => {\n                if (thumb === Thumb.START) {\n                    return this.startThumbKnob.getBoundingClientRect().width;\n                }\n                return this.endThumbKnob.getBoundingClientRect().width;\n            },\n            getValueToAriaValueTextFn: () => {\n                return this.valueToAriaTextTransform;\n            },\n            isInputFocused: (thumb) => {\n                const activeElements = deepActiveElementPath();\n                const deepActivEl = activeElements[activeElements.length - 1];\n                if (thumb === Thumb.START) {\n                    return deepActivEl === this.startInput;\n                }\n                return deepActivEl === this.formElement;\n            },\n            isRTL: () => {\n                return getComputedStyle(this).direction === 'rtl';\n            },\n            setInputAttribute: (attribute, _value, thumb) => {\n                if (thumb === Thumb.START) {\n                    switch (attribute) {\n                        case 'disabled':\n                        case 'value':\n                        case 'aria-valuetext':\n                            // handled by bindings\n                            break;\n                    }\n                }\n                switch (attribute) {\n                    case 'disabled':\n                    case 'value':\n                    case 'aria-valuetext':\n                        // handled by bindings\n                        break;\n                }\n            },\n            removeInputAttribute: (attribute) => {\n                switch (attribute) {\n                    case 'disabled':\n                        // handled by bindings\n                        break;\n                }\n            },\n            setThumbStyleProperty: (name, value, thumb) => {\n                if (thumb === Thumb.START) {\n                    switch (name) {\n                        case 'transform':\n                        case '-webkit-transform':\n                            this.startThumbTransformStyle = value;\n                            break;\n                        case 'transition':\n                        case '-webkit-transition':\n                            this.startThumbTransitionStyle = value;\n                            break;\n                    }\n                }\n                else {\n                    switch (name) {\n                        case 'transform':\n                        case '-webkit-transform':\n                            this.endThumbTransformStyle = value;\n                            break;\n                        case 'transition':\n                        case '-webkit-transition':\n                            this.endThumbTransitionStyle = value;\n                            break;\n                    }\n                }\n            },\n            removeThumbStyleProperty: (name, thumb) => {\n                if (thumb === Thumb.START) {\n                    switch (name) {\n                        case 'left':\n                        case 'right':\n                            // handled by bindings\n                            break;\n                        case 'transition':\n                        case '-webkit-transition':\n                            this.startThumbTransitionStyle = '';\n                            break;\n                    }\n                }\n                else {\n                    switch (name) {\n                        case 'left':\n                        case 'right':\n                            // handled by bindings\n                            break;\n                        case 'transition':\n                        case '-webkit-transition':\n                            this.endThumbTransitionStyle = '';\n                            break;\n                    }\n                }\n            },\n            setTrackActiveStyleProperty: (name, value) => {\n                switch (name) {\n                    case 'transform-origin':\n                        this.trackTransformOriginStyle = value;\n                        break;\n                    case 'left':\n                        this.trackLeftStyle = value;\n                        break;\n                    case 'right':\n                        this.trackRightStyle = value;\n                        break;\n                    case 'transform':\n                    case '-webkit-transform':\n                        // handled by bindings\n                        break;\n                    case 'transition':\n                    case '-webkit-transition':\n                        this.trackTransitionStyle = value;\n                        break;\n                }\n            },\n            removeTrackActiveStyleProperty: (name) => {\n                switch (name) {\n                    case 'transition':\n                    case '-webkit-transition':\n                        this.trackTransitionStyle = '';\n                        break;\n                }\n            },\n            setInputValue: (value, thumb) => {\n                if (thumb === Thumb.START) {\n                    this.valueStart = Number(value);\n                }\n                else {\n                    this.valueEnd = Number(value);\n                }\n            },\n            setPointerCapture: (pointerId) => {\n                this.mdcRoot.setPointerCapture(pointerId);\n            },\n            setValueIndicatorText: () => {\n                // handled by bidnings\n            },\n            updateTickMarks: (tickMarks) => {\n                this.tickMarks = tickMarks;\n            },\n        };\n    }\n    onStartChange(e) {\n        var _a;\n        this.valueStart = Number(e.target.value);\n        (_a = this.mdcFoundation) === null || _a === void 0 ? void 0 : _a.handleInputChange(Thumb.START);\n    }\n    onStartFocus() {\n        var _a;\n        (_a = this.mdcFoundation) === null || _a === void 0 ? void 0 : _a.handleInputFocus(Thumb.START);\n        this.startRippleHandlers.startFocus();\n    }\n    onStartBlur() {\n        var _a;\n        (_a = this.mdcFoundation) === null || _a === void 0 ? void 0 : _a.handleInputBlur(Thumb.START);\n        this.startRippleHandlers.endFocus();\n    }\n    onStartMouseenter() {\n        var _a;\n        (_a = this.mdcFoundation) === null || _a === void 0 ? void 0 : _a.handleThumbMouseenter();\n        this.startRippleHandlers.startHover();\n    }\n    onStartMouseleave() {\n        var _a;\n        (_a = this.mdcFoundation) === null || _a === void 0 ? void 0 : _a.handleThumbMouseleave();\n        this.startRippleHandlers.endHover();\n    }\n    setFormData(formData) {\n        if (this.name) {\n            formData.append(`${this.name}-start`, `${this.valueStart}`);\n            formData.append(`${this.name}-end`, `${this.valueEnd}`);\n        }\n    }\n}\n__decorate([\n    query('input.start')\n], SliderRangeBase.prototype, \"startInput\", void 0);\n__decorate([\n    query('.start.mdc-slider__thumb')\n], SliderRangeBase.prototype, \"startThumb\", void 0);\n__decorate([\n    query('.start.mdc-slider__thumb .mdc-slider__thumb-knob')\n], SliderRangeBase.prototype, \"startThumbKnob\", void 0);\n__decorate([\n    queryAsync('.start .ripple')\n], SliderRangeBase.prototype, \"startRipple\", void 0);\n__decorate([\n    property({ type: Number })\n], SliderRangeBase.prototype, \"valueStart\", void 0);\n__decorate([\n    state()\n], SliderRangeBase.prototype, \"startThumbWithIndicator\", void 0);\n__decorate([\n    state()\n], SliderRangeBase.prototype, \"startThumbTop\", void 0);\n__decorate([\n    state()\n], SliderRangeBase.prototype, \"shouldRenderStartRipple\", void 0);\n__decorate([\n    state()\n], SliderRangeBase.prototype, \"startThumbTransformStyle\", void 0);\n__decorate([\n    state()\n], SliderRangeBase.prototype, \"startThumbTransitionStyle\", void 0);\n//# sourceMappingURL=slider-range-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-ripple/mwc-ripple';\nimport { deepActiveElementPath } from '@material/mwc-base/utils';\nimport { Thumb } from '@material/slider/types';\nimport { html } from 'lit';\nimport { property } from 'lit/decorators.js';\nimport { styleMap } from 'lit/directives/style-map.js';\nimport { SliderBase } from './slider-base';\nexport { Thumb } from '@material/slider/types';\nexport class SliderSingleBase extends SliderBase {\n    get value() {\n        return this.valueEnd;\n    }\n    set value(newVal) {\n        this.valueEnd = newVal;\n    }\n    renderTrack() {\n        const trackStyles = styleMap({\n            'transform-origin': this.trackTransformOriginStyle,\n            'left': this.trackLeftStyle,\n            'right': this.trackRightStyle,\n            '-webkit-transform': `scaleX(${(this.valueEnd - this.min) / (this.max - this.min)})`,\n            'transform': `scaleX(${(this.valueEnd - this.min) / (this.max - this.min)})`,\n            '-webkit-transition': this.trackTransitionStyle,\n            'transition': this.trackTransitionStyle,\n        });\n        return html `\n      <div class=\"mdc-slider__track\">\n        <div class=\"mdc-slider__track--inactive\"></div>\n        <div class=\"mdc-slider__track--active\">\n          <div\n              class=\"mdc-slider__track--active_fill\"\n              style=${trackStyles}>\n          </div>\n        </div>\n      </div>`;\n    }\n    createAdapter() {\n        return {\n            addClass: (className) => {\n                switch (className) {\n                    case 'mdc-slider--disabled':\n                        this.disabled = true;\n                        break;\n                }\n            },\n            removeClass: (className) => {\n                switch (className) {\n                    case 'mdc-slider--disabled':\n                        this.disabled = false;\n                        break;\n                }\n            },\n            hasClass: (className) => {\n                switch (className) {\n                    case 'mdc-slider--disabled':\n                        return this.disabled;\n                    case 'mdc-slider--discrete':\n                        return this.discrete;\n                    default:\n                        return false;\n                }\n            },\n            addThumbClass: (className, thumb) => {\n                if (thumb === Thumb.START) {\n                    return;\n                }\n                switch (className) {\n                    case 'mdc-slider__thumb--with-indicator':\n                        this.endThumbWithIndicator = true;\n                        break;\n                }\n            },\n            removeThumbClass: (className, thumb) => {\n                if (thumb === Thumb.START) {\n                    return;\n                }\n                switch (className) {\n                    case 'mdc-slider__thumb--with-indicator':\n                        this.endThumbWithIndicator = false;\n                        break;\n                }\n            },\n            registerEventHandler: () => {\n                // handled in bindings\n            },\n            deregisterEventHandler: () => {\n                // handled in bindings\n            },\n            registerBodyEventHandler: (eventName, handler) => {\n                document.body.addEventListener(eventName, handler);\n            },\n            deregisterBodyEventHandler: (eventName, handler) => {\n                document.body.removeEventListener(eventName, handler);\n            },\n            registerInputEventHandler: (thumb, eventName, handler) => {\n                if (thumb === Thumb.START) {\n                    return;\n                }\n                this.formElement.addEventListener(eventName, handler);\n            },\n            deregisterInputEventHandler: (thumb, eventName, handler) => {\n                if (thumb === Thumb.START) {\n                    return;\n                }\n                this.formElement.removeEventListener(eventName, handler);\n            },\n            registerThumbEventHandler: () => {\n                // handled by bindings\n            },\n            deregisterThumbEventHandler: () => {\n                // handled by bindings\n            },\n            registerWindowEventHandler: (eventName, handler) => {\n                window.addEventListener(eventName, handler);\n            },\n            deregisterWindowEventHandler: (eventName, handler) => {\n                window.addEventListener(eventName, handler);\n            },\n            emitChangeEvent: (value, thumb) => {\n                if (thumb === Thumb.START) {\n                    return;\n                }\n                const event = new CustomEvent('change', { bubbles: true, composed: true, detail: { value, thumb } });\n                this.dispatchEvent(event);\n            },\n            emitDragEndEvent: (_value, thumb) => {\n                if (thumb === Thumb.START) {\n                    return;\n                }\n                // Emitting event is not yet implemented. See issue:\n                // https://github.com/material-components/material-components-web/issues/6448\n                this.endRippleHandlers.endPress();\n            },\n            emitDragStartEvent: (_value, thumb) => {\n                if (thumb === Thumb.START) {\n                    return;\n                }\n                // Emitting event is not yet implemented. See issue:\n                // https://github.com/material-components/material-components-web/issues/6448\n                this.endRippleHandlers.startPress();\n            },\n            emitInputEvent: (value, thumb) => {\n                if (thumb === Thumb.START) {\n                    return;\n                }\n                const event = new CustomEvent('input', { bubbles: true, composed: true, detail: { value, thumb } });\n                this.dispatchEvent(event);\n            },\n            focusInput: (thumb) => {\n                if (thumb === Thumb.START) {\n                    return;\n                }\n                this.formElement.focus();\n            },\n            getAttribute: () => {\n                // never seems to actually be used\n                return '';\n            },\n            getBoundingClientRect: () => {\n                return this.mdcRoot.getBoundingClientRect();\n            },\n            getInputAttribute: (attrName, thumb) => {\n                if (thumb === Thumb.START) {\n                    return null;\n                }\n                switch (attrName) {\n                    case 'min':\n                        return this.min.toString();\n                    case 'max':\n                        return this.max.toString();\n                    case 'value':\n                        return this.valueEnd.toString();\n                    case 'step':\n                        return this.step.toString();\n                    default:\n                        return null;\n                }\n            },\n            getInputValue: (thumb) => {\n                if (thumb === Thumb.START) {\n                    return '';\n                }\n                return this.valueEnd.toString();\n            },\n            getThumbBoundingClientRect: (thumb) => {\n                if (thumb === Thumb.START) {\n                    return this.getBoundingClientRect();\n                }\n                return this.endThumb.getBoundingClientRect();\n            },\n            getThumbKnobWidth: (thumb) => {\n                if (thumb === Thumb.START) {\n                    return 0;\n                }\n                return this.endThumbKnob.getBoundingClientRect().width;\n            },\n            getValueToAriaValueTextFn: () => {\n                return this.valueToAriaTextTransform;\n            },\n            isInputFocused: (thumb) => {\n                if (thumb === Thumb.START) {\n                    return false;\n                }\n                const activeElements = deepActiveElementPath();\n                return activeElements[activeElements.length - 1] === this.formElement;\n            },\n            isRTL: () => {\n                return getComputedStyle(this).direction === 'rtl';\n            },\n            setInputAttribute: (attribute, _value, thumb) => {\n                if (thumb === Thumb.START) {\n                    return;\n                }\n                switch (attribute) {\n                    case 'disabled':\n                    case 'value':\n                    case 'aria-valuetext':\n                        // handled by bindings\n                        break;\n                }\n            },\n            removeInputAttribute: (attribute) => {\n                switch (attribute) {\n                    case 'disabled':\n                        // handled by bindings\n                        break;\n                }\n            },\n            setThumbStyleProperty: (name, value, thumb) => {\n                if (thumb === Thumb.START) {\n                    return;\n                }\n                switch (name) {\n                    case 'transform':\n                    case '-webkit-transform':\n                        this.endThumbTransformStyle = value;\n                        break;\n                    case 'transition':\n                    case '-webkit-transition':\n                        this.endThumbTransitionStyle = value;\n                        break;\n                }\n            },\n            removeThumbStyleProperty: (name, thumb) => {\n                if (thumb === Thumb.START) {\n                    return;\n                }\n                switch (name) {\n                    case 'left':\n                    case 'right':\n                        // handled by bindings\n                        break;\n                    case 'transition':\n                    case '-webkit-transition':\n                        this.endThumbTransitionStyle = '';\n                        break;\n                }\n            },\n            setTrackActiveStyleProperty: (name, value) => {\n                switch (name) {\n                    case 'transform-origin':\n                        this.trackTransformOriginStyle = value;\n                        break;\n                    case 'left':\n                        this.trackLeftStyle = value;\n                        break;\n                    case 'right':\n                        this.trackRightStyle = value;\n                        break;\n                    case 'transform':\n                    case '-webkit-transform':\n                        // handled by bindings\n                        break;\n                    case 'transition':\n                    case '-webkit-transition':\n                        this.trackTransitionStyle = value;\n                        break;\n                }\n            },\n            removeTrackActiveStyleProperty: (name) => {\n                switch (name) {\n                    case 'transition':\n                    case '-webkit-transition':\n                        this.trackTransitionStyle = '';\n                        break;\n                }\n            },\n            setInputValue: (value, thumb) => {\n                if (thumb === Thumb.START) {\n                    return;\n                }\n                this.valueEnd = Number(value);\n            },\n            setPointerCapture: (pointerId) => {\n                this.mdcRoot.setPointerCapture(pointerId);\n            },\n            setValueIndicatorText: () => {\n                // handled by bindings\n            },\n            updateTickMarks: (tickMarks) => {\n                this.tickMarks = tickMarks;\n            },\n        };\n    }\n}\n__decorate([\n    property({ type: Number })\n], SliderSingleBase.prototype, \"value\", null);\n//# sourceMappingURL=slider-single-base.js.map","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport MDCSnackbarFoundation from '@material/snackbar/foundation';\nimport { html, render } from 'lit';\nimport { AsyncDirective } from 'lit/async-directive.js';\nimport { directive, PartType } from 'lit/directive.js';\nconst { ARIA_LIVE_DELAY_MS } = MDCSnackbarFoundation.numbers;\n/**\n * A lit directive implementation of @material/mdc-snackbar/util.ts#announce,\n * which does some tricks to ensure that snackbar labels will be handled\n * correctly by screen readers.\n *\n * The existing MDC announce util function is difficult to use directly here,\n * because Lit can crash when DOM that it is managing changes outside of its\n * purvue. In this case, we would render our labelText as the text content of\n * the label div, but the MDC announce function then clears that text content,\n * and resets it after a timeout (see below for why). We do the same thing here,\n * but in a way that fits into Lit's lifecycle.\n *\n * TODO(aomarks) Investigate whether this can be simplified; but to do that we\n * first need testing infrastructure to verify that it remains compatible with\n * screen readers. For example, can we just create an entirely new label node\n * every time we open or labelText changes? If not, and the async text/::before\n * swap is strictly required, can we at elast make this directive more generic\n * (e.g. so that we don't hard-code the name of the label class).\n */\nclass AccessibleSnackbarLabel extends AsyncDirective {\n    constructor(partInfo) {\n        super(partInfo);\n        this.labelEl = null;\n        this.timerId = null;\n        this.previousPart = null;\n        if (partInfo.type !== PartType.CHILD) {\n            throw new Error('AccessibleSnackbarLabel only supports child parts.');\n        }\n    }\n    update(part, [labelText, isOpen]) {\n        var _a;\n        if (!isOpen) {\n            // We never need to do anything if we're closed, even if the label also\n            // changed in this batch of changes. We'll fully reset the label text\n            // whenever we next open.\n            return;\n        }\n        if (this.labelEl === null) {\n            // Create the label element once, the first time we open.\n            const wrapperEl = document.createElement('div');\n            const labelTemplate = html `<div class=\"mdc-snackbar__label\" role=\"status\" aria-live=\"polite\"></div>`;\n            render(labelTemplate, wrapperEl);\n            const labelEl = wrapperEl.firstElementChild;\n            labelEl.textContent = labelText;\n            // endNode can't be a Document, so it must have a parent.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            (_a = part.endNode) === null || _a === void 0 ? void 0 : _a.parentNode.insertBefore(labelEl, part.endNode);\n            this.labelEl = labelEl;\n            // No need to do anything more for ARIA the first time we open. We just\n            // created the element with the current label, so screen readers will\n            // detect it fine.\n            return labelEl;\n        }\n        const labelEl = this.labelEl;\n        // Temporarily disable `aria-live` to prevent JAWS+Firefox from announcing\n        // the message twice.\n        labelEl.setAttribute('aria-live', 'off');\n        // Temporarily clear `textContent` to force a DOM mutation event that will\n        // be detected by screen readers. `aria-live` elements are only announced\n        // when the element's `textContent` *changes*, so snackbars sent to the\n        // browser in the initial HTML response won't be read unless we clear the\n        // element's `textContent` first. Similarly, displaying the same snackbar\n        // message twice in a row doesn't trigger a DOM mutation event, so screen\n        // readers won't announce the second message unless we first clear\n        // `textContent`.\n        //\n        // We have to clear the label text two different ways to make it work in\n        // all browsers and screen readers:\n        //\n        //   1. `textContent = ''` is required for IE11 + JAWS\n        //   2. the lit render of `'&nbsp;'` is required for Chrome + JAWS and\n        //       NVDA\n        //\n        // All other browser/screen reader combinations support both methods.\n        //\n        // The wrapper `<span>` visually hides the space character so that it\n        // doesn't cause jank when added/removed. N.B.: Setting `position:\n        // absolute`, `opacity: 0`, or `height: 0` prevents Chrome from detecting\n        // the DOM change.\n        //\n        // This technique has been tested in:\n        //\n        //   * JAWS 2019:\n        //       - Chrome 70\n        //       - Firefox 60 (ESR)\n        //       - IE 11\n        //   * NVDA 2018:\n        //       - Chrome 70\n        //       - Firefox 60 (ESR)\n        //       - IE 11\n        //   * ChromeVox 53\n        labelEl.textContent = '';\n        // Updating an element using both Lit's `render` as well as setting its\n        // `textContent` can cause later renders to throw because setting\n        // `textContent` will remove Lit's part marker comments. This directive\n        // needs to set `labelEl`'s `textContent` to trigger the expected screen\n        // reader behavior, so it needs to avoid `render` for `labelEl` altogether.\n        const spaceSpan = document.createElement('span');\n        spaceSpan.style.display = 'inline-block';\n        spaceSpan.style.width = '0';\n        spaceSpan.style.height = '1px';\n        spaceSpan.textContent = '\\u00A0'; // U+00A0 is &nbsp;\n        labelEl.appendChild(spaceSpan);\n        // Prevent visual jank by temporarily displaying the label text in the\n        // ::before pseudo-element. CSS generated content is normally announced by\n        // screen readers (except in IE 11; see\n        // https://tink.uk/accessibility-support-for-css-generated-content/);\n        // however, `aria-live` is turned off, so this DOM update will be ignored\n        // by screen readers.\n        labelEl.setAttribute('data-mdc-snackbar-label-text', labelText);\n        if (this.timerId !== null) {\n            // We hadn't yet swapped the textContent back in since the last time we\n            // opened or changed the label. Cancel that task so we don't clobber the\n            // new label.\n            clearTimeout(this.timerId);\n        }\n        this.timerId = window.setTimeout(() => {\n            this.timerId = null;\n            // Allow screen readers to announce changes to the DOM again.\n            labelEl.setAttribute('aria-live', 'polite');\n            // Remove the message from the ::before pseudo-element.\n            labelEl.removeAttribute('data-mdc-snackbar-label-text');\n            // Restore the original label text, which will be announced by\n            // screen readers.\n            labelEl.textContent = labelText;\n            this.setValue(this.labelEl);\n        }, ARIA_LIVE_DELAY_MS);\n        return labelEl;\n    }\n    render(labelText, isOpen) {\n        if (!isOpen) {\n            return html ``;\n        }\n        return html `\n      <div class=\"mdc-snackbar__label\" role=\"status\" aria-live=\"polite\">${labelText}</div>`;\n    }\n}\nexport const accessibleSnackbarLabel = directive(AccessibleSnackbarLabel);\n//# sourceMappingURL=accessible-snackbar-label-directive.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport { addHasRemoveClass, BaseElement } from '@material/mwc-base/base-element';\nimport { observer } from '@material/mwc-base/observer';\nimport MDCSnackbarFoundation from '@material/snackbar/foundation';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { accessibleSnackbarLabel } from './accessible-snackbar-label-directive';\nconst { OPENING_EVENT, OPENED_EVENT, CLOSING_EVENT, CLOSED_EVENT, } = MDCSnackbarFoundation.strings;\nexport class SnackbarBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.mdcFoundationClass = MDCSnackbarFoundation;\n        this.open = false;\n        this.timeoutMs = 5000;\n        this.closeOnEscape = false;\n        this.labelText = '';\n        this.stacked = false;\n        this.leading = false;\n        this.reason = '';\n    }\n    render() {\n        const classes = {\n            'mdc-snackbar--stacked': this.stacked,\n            'mdc-snackbar--leading': this.leading,\n        };\n        return html `\n      <div class=\"mdc-snackbar ${classMap(classes)}\" @keydown=\"${this._handleKeydown}\">\n        <div class=\"mdc-snackbar__surface\">\n          ${accessibleSnackbarLabel(this.labelText, this.open)}\n          <div class=\"mdc-snackbar__actions\">\n            <slot name=\"action\" @click=\"${this._handleActionClick}\"></slot>\n            <slot name=\"dismiss\" @click=\"${this._handleDismissClick}\"></slot>\n          </div>\n        </div>\n      </div>`;\n    }\n    createAdapter() {\n        return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { announce: () => {\n                /* We handle announce ourselves with the accessible directive. */\n            }, notifyClosed: (reason) => {\n                this.dispatchEvent(new CustomEvent(CLOSED_EVENT, { bubbles: true, cancelable: true, detail: { reason: reason } }));\n            }, notifyClosing: (reason) => {\n                this.open = false;\n                this.dispatchEvent(new CustomEvent(CLOSING_EVENT, { bubbles: true, cancelable: true, detail: { reason: reason } }));\n            }, notifyOpened: () => {\n                this.dispatchEvent(new CustomEvent(OPENED_EVENT, { bubbles: true, cancelable: true }));\n            }, notifyOpening: () => {\n                this.open = true;\n                this.dispatchEvent(new CustomEvent(OPENING_EVENT, { bubbles: true, cancelable: true }));\n            } });\n    }\n    /** @export */\n    show() {\n        this.open = true;\n    }\n    /** @export */\n    close(reason = '') {\n        this.reason = reason;\n        this.open = false;\n    }\n    firstUpdated() {\n        super.firstUpdated();\n        if (this.open) {\n            this.mdcFoundation.open();\n        }\n    }\n    _handleKeydown(e) {\n        this.mdcFoundation.handleKeyDown(e);\n    }\n    _handleActionClick(e) {\n        this.mdcFoundation.handleActionButtonClick(e);\n    }\n    _handleDismissClick(e) {\n        this.mdcFoundation.handleActionIconClick(e);\n    }\n}\n__decorate([\n    query('.mdc-snackbar')\n], SnackbarBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('.mdc-snackbar__label')\n], SnackbarBase.prototype, \"labelElement\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            if (value) {\n                this.mdcFoundation.open();\n            }\n            else {\n                this.mdcFoundation.close(this.reason);\n                this.reason = '';\n            }\n        }\n    })\n], SnackbarBase.prototype, \"open\", void 0);\n__decorate([\n    observer(function (value) {\n        this.mdcFoundation.setTimeoutMs(value);\n    }),\n    property({ type: Number })\n], SnackbarBase.prototype, \"timeoutMs\", void 0);\n__decorate([\n    observer(function (value) {\n        this.mdcFoundation.setCloseOnEscape(value);\n    }),\n    property({ type: Boolean })\n], SnackbarBase.prototype, \"closeOnEscape\", void 0);\n__decorate([\n    property({ type: String })\n], SnackbarBase.prototype, \"labelText\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SnackbarBase.prototype, \"stacked\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SnackbarBase.prototype, \"leading\", void 0);\n//# sourceMappingURL=mwc-snackbar-base.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport '@material/mwc-ripple/mwc-ripple';\nimport { ariaProperty } from '@material/mwc-base/aria-property';\nimport { FormElement } from '@material/mwc-base/form-element';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers';\nimport { MDCSwitchFoundation } from '@material/switch/foundation';\nimport { html } from 'lit';\nimport { eventOptions, property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nexport class SwitchBase extends FormElement {\n    constructor() {\n        super(...arguments);\n        // MDCSwitchState\n        this.processing = false;\n        this.selected = false;\n        // Aria\n        /** @soyPrefixAttribute */\n        this.ariaLabel = '';\n        /** @soyPrefixAttribute */\n        this.ariaLabelledBy = '';\n        this.shouldRenderRipple = false;\n        this.rippleHandlers = new RippleHandlers(() => {\n            this.shouldRenderRipple = true;\n            return this.ripple;\n        });\n        // FormElement\n        this.name = '';\n        this.value = 'on';\n        this.mdcFoundationClass = MDCSwitchFoundation;\n    }\n    setFormData(formData) {\n        if (this.name && this.selected) {\n            formData.append(this.name, this.value);\n        }\n    }\n    click() {\n        var _a, _b;\n        // Switch uses a hidden input as its form element, but a different <button>\n        // for interaction. It overrides click() from FormElement to avoid clicking\n        // the hidden input.\n        if (this.disabled) {\n            return;\n        }\n        (_a = this.mdcRoot) === null || _a === void 0 ? void 0 : _a.focus();\n        (_b = this.mdcRoot) === null || _b === void 0 ? void 0 : _b.click();\n    }\n    /** @soyTemplate */\n    render() {\n        return html `\n      <button\n        type=\"button\"\n        class=\"mdc-switch ${classMap(this.getRenderClasses())}\"\n        role=\"switch\"\n        aria-checked=\"${this.selected}\"\n        aria-label=\"${ifDefined(this.ariaLabel || undefined)}\"\n        aria-labelledby=\"${ifDefined(this.ariaLabelledBy || undefined)}\"\n        .disabled=${this.disabled}\n        @click=${this.handleClick}\n        @focus=\"${this.handleFocus}\"\n        @blur=\"${this.handleBlur}\"\n        @pointerdown=\"${this.handlePointerDown}\"\n        @pointerup=\"${this.handlePointerUp}\"\n        @pointerenter=\"${this.handlePointerEnter}\"\n        @pointerleave=\"${this.handlePointerLeave}\"\n      >\n        <div class=\"mdc-switch__track\"></div>\n        <div class=\"mdc-switch__handle-track\">\n          ${this.renderHandle()}\n        </div>\n      </button>\n\n      <input\n        type=\"checkbox\"\n        aria-hidden=\"true\"\n        name=\"${this.name}\"\n        .checked=${this.selected}\n        .value=${this.value}\n      >\n    `;\n    }\n    /** @soyTemplate */\n    getRenderClasses() {\n        return {\n            'mdc-switch--processing': this.processing,\n            'mdc-switch--selected': this.selected,\n            'mdc-switch--unselected': !this.selected,\n        };\n    }\n    /** @soyTemplate */\n    renderHandle() {\n        return html `\n      <div class=\"mdc-switch__handle\">\n        ${this.renderShadow()}\n        ${this.renderRipple()}\n        <div class=\"mdc-switch__icons\">\n          ${this.renderOnIcon()}\n          ${this.renderOffIcon()}\n        </div>\n      </div>\n    `;\n    }\n    /** @soyTemplate */\n    renderShadow() {\n        return html `\n      <div class=\"mdc-switch__shadow\">\n        <div class=\"mdc-elevation-overlay\"></div>\n      </div>\n    `;\n    }\n    /** @soyTemplate */\n    renderRipple() {\n        if (this.shouldRenderRipple) {\n            return html `\n        <div class=\"mdc-switch__ripple\">\n          <mwc-ripple\n            internalUseStateLayerCustomProperties\n            .disabled=\"${this.disabled}\"\n            unbounded>\n          </mwc-ripple>\n        </div>\n      `;\n        }\n        else {\n            return html ``;\n        }\n    }\n    /** @soyTemplate */\n    renderOnIcon() {\n        return html `\n      <svg class=\"mdc-switch__icon mdc-switch__icon--on\" viewBox=\"0 0 24 24\">\n        <path d=\"M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z\" />\n      </svg>\n    `;\n    }\n    /** @soyTemplate */\n    renderOffIcon() {\n        return html `\n      <svg class=\"mdc-switch__icon mdc-switch__icon--off\" viewBox=\"0 0 24 24\">\n        <path d=\"M20 13H4v-2h16v2z\" />\n      </svg>\n    `;\n    }\n    handleClick() {\n        var _a;\n        (_a = this.mdcFoundation) === null || _a === void 0 ? void 0 : _a.handleClick();\n    }\n    handleFocus() {\n        this.rippleHandlers.startFocus();\n    }\n    handleBlur() {\n        this.rippleHandlers.endFocus();\n    }\n    handlePointerDown(event) {\n        event.target.setPointerCapture(event.pointerId);\n        this.rippleHandlers.startPress(event);\n    }\n    handlePointerUp() {\n        this.rippleHandlers.endPress();\n    }\n    handlePointerEnter() {\n        this.rippleHandlers.startHover();\n    }\n    handlePointerLeave() {\n        this.rippleHandlers.endHover();\n    }\n    createAdapter() {\n        return { state: this };\n    }\n}\n__decorate([\n    property({ type: Boolean })\n], SwitchBase.prototype, \"processing\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SwitchBase.prototype, \"selected\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-label' })\n], SwitchBase.prototype, \"ariaLabel\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-labelledby' })\n], SwitchBase.prototype, \"ariaLabelledBy\", void 0);\n__decorate([\n    queryAsync('mwc-ripple')\n], SwitchBase.prototype, \"ripple\", void 0);\n__decorate([\n    state()\n], SwitchBase.prototype, \"shouldRenderRipple\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], SwitchBase.prototype, \"name\", void 0);\n__decorate([\n    property({ type: String })\n], SwitchBase.prototype, \"value\", void 0);\n__decorate([\n    query('input')\n], SwitchBase.prototype, \"formElement\", void 0);\n__decorate([\n    query('.mdc-switch')\n], SwitchBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    eventOptions({ passive: true })\n], SwitchBase.prototype, \"handlePointerDown\", null);\n//# sourceMappingURL=mwc-switch-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport { matches } from '@material/dom/ponyfill';\nimport { addHasRemoveClass, BaseElement } from '@material/mwc-base/base-element';\nimport MDCTabScrollerFoundation from '@material/tab-scroller/foundation';\nimport { html } from 'lit';\nimport { eventOptions, query } from 'lit/decorators.js';\nexport class TabScrollerBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.mdcFoundationClass = MDCTabScrollerFoundation;\n        this._scrollbarHeight = -1;\n    }\n    _handleInteraction() {\n        this.mdcFoundation.handleInteraction();\n    }\n    _handleTransitionEnd(e) {\n        this.mdcFoundation.handleTransitionEnd(e);\n    }\n    render() {\n        return html `\n      <div class=\"mdc-tab-scroller\">\n        <div class=\"mdc-tab-scroller__scroll-area\"\n            @wheel=\"${this._handleInteraction}\"\n            @touchstart=\"${this._handleInteraction}\"\n            @pointerdown=\"${this._handleInteraction}\"\n            @mousedown=\"${this._handleInteraction}\"\n            @keydown=\"${this._handleInteraction}\"\n            @transitionend=\"${this._handleTransitionEnd}\">\n          <div class=\"mdc-tab-scroller__scroll-content\"><slot></slot></div>\n        </div>\n      </div>\n      `;\n    }\n    createAdapter() {\n        return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { eventTargetMatchesSelector: (evtTarget, selector) => matches(evtTarget, selector), addScrollAreaClass: (className) => this.scrollAreaElement.classList.add(className), setScrollAreaStyleProperty: (prop, value) => this.scrollAreaElement.style.setProperty(prop, value), setScrollContentStyleProperty: (prop, value) => this.scrollContentElement.style.setProperty(prop, value), getScrollContentStyleValue: (propName) => window.getComputedStyle(this.scrollContentElement)\n                .getPropertyValue(propName), setScrollAreaScrollLeft: (scrollX) => this.scrollAreaElement.scrollLeft = scrollX, getScrollAreaScrollLeft: () => this.scrollAreaElement.scrollLeft, getScrollContentOffsetWidth: () => this.scrollContentElement.offsetWidth, getScrollAreaOffsetWidth: () => this.scrollAreaElement.offsetWidth, computeScrollAreaClientRect: () => this.scrollAreaElement.getBoundingClientRect(), computeScrollContentClientRect: () => this.scrollContentElement.getBoundingClientRect(), computeHorizontalScrollbarHeight: () => {\n                if (this._scrollbarHeight === -1) {\n                    this.scrollAreaElement.style.overflowX = 'scroll';\n                    this._scrollbarHeight = this.scrollAreaElement.offsetHeight -\n                        this.scrollAreaElement.clientHeight;\n                    this.scrollAreaElement.style.overflowX = '';\n                }\n                return this._scrollbarHeight;\n            } });\n    }\n    /**\n     * Returns the current visual scroll position\n     * @return {number}\n     */\n    getScrollPosition() {\n        return this.mdcFoundation.getScrollPosition();\n    }\n    /**\n     * Returns the width of the scroll content\n     * @return {number}\n     */\n    getScrollContentWidth() {\n        return this.scrollContentElement.offsetWidth;\n    }\n    /**\n     * Increments the scroll value by the given amount\n     * @param {number} scrollXIncrement The pixel value by which to increment the\n     *     scroll value\n     */\n    incrementScrollPosition(scrollXIncrement) {\n        this.mdcFoundation.incrementScroll(scrollXIncrement);\n    }\n    /**\n     * Scrolls to the given pixel position\n     * @param {number} scrollX The pixel value to scroll to\n     */\n    scrollToPosition(scrollX) {\n        this.mdcFoundation.scrollTo(scrollX);\n    }\n}\n__decorate([\n    query('.mdc-tab-scroller')\n], TabScrollerBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('.mdc-tab-scroller__scroll-area')\n], TabScrollerBase.prototype, \"scrollAreaElement\", void 0);\n__decorate([\n    query('.mdc-tab-scroller__scroll-content')\n], TabScrollerBase.prototype, \"scrollContentElement\", void 0);\n__decorate([\n    eventOptions({ passive: true })\n], TabScrollerBase.prototype, \"_handleInteraction\", null);\n//# sourceMappingURL=mwc-tab-scroller-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n// Make TypeScript not remove the imports.\nimport '@material/mwc-tab';\nimport '@material/mwc-tab-scroller';\nimport { BaseElement } from '@material/mwc-base/base-element';\nimport { observer } from '@material/mwc-base/observer';\nimport { TabBase } from '@material/mwc-tab/mwc-tab-base';\nimport MDCTabBarFoundation from '@material/tab-bar/foundation';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nexport class TabBarBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.mdcFoundationClass = MDCTabBarFoundation;\n        this.activeIndex = 0;\n        this._previousActiveIndex = -1;\n    }\n    _handleTabInteraction(e) {\n        this.mdcFoundation.handleTabInteraction(e);\n    }\n    _handleKeydown(e) {\n        this.mdcFoundation.handleKeyDown(e);\n    }\n    // TODO(sorvell): can scroller be optional for perf?\n    render() {\n        return html `\n      <div class=\"mdc-tab-bar\" role=\"tablist\"\n          @MDCTab:interacted=\"${this._handleTabInteraction}\"\n          @keydown=\"${this._handleKeydown}\">\n        <mwc-tab-scroller><slot></slot></mwc-tab-scroller>\n      </div>\n      `;\n    }\n    // TODO(sorvell): probably want to memoize this and use a `slotChange` event\n    _getTabs() {\n        return this.tabsSlot\n            .assignedNodes({ flatten: true })\n            .filter((e) => e instanceof TabBase);\n    }\n    _getTab(index) {\n        return this._getTabs()[index];\n    }\n    createAdapter() {\n        return {\n            scrollTo: (scrollX) => this.scrollerElement.scrollToPosition(scrollX),\n            incrementScroll: (scrollXIncrement) => this.scrollerElement.incrementScrollPosition(scrollXIncrement),\n            getScrollPosition: () => this.scrollerElement.getScrollPosition(),\n            getScrollContentWidth: () => this.scrollerElement.getScrollContentWidth(),\n            getOffsetWidth: () => this.mdcRoot.offsetWidth,\n            isRTL: () => window.getComputedStyle(this.mdcRoot)\n                .getPropertyValue('direction') === 'rtl',\n            setActiveTab: (index) => this.mdcFoundation.activateTab(index),\n            activateTabAtIndex: (index, clientRect) => {\n                const tab = this._getTab(index);\n                if (tab !== undefined) {\n                    tab.activate(clientRect);\n                }\n                this._previousActiveIndex = index;\n            },\n            deactivateTabAtIndex: (index) => {\n                const tab = this._getTab(index);\n                if (tab !== undefined) {\n                    tab.deactivate();\n                }\n            },\n            focusTabAtIndex: (index) => {\n                const tab = this._getTab(index);\n                if (tab !== undefined) {\n                    tab.focus();\n                }\n            },\n            // TODO(sorvell): tab may not be able to synchronously answer\n            // `computeIndicatorClientRect` if an update is pending or it has not yet\n            // updated. If this is necessary, LitElement may need a `forceUpdate`\n            // method.\n            getTabIndicatorClientRectAtIndex: (index) => {\n                const tab = this._getTab(index);\n                return tab !== undefined ? tab.computeIndicatorClientRect() :\n                    new DOMRect();\n            },\n            getTabDimensionsAtIndex: (index) => {\n                const tab = this._getTab(index);\n                return tab !== undefined ?\n                    tab.computeDimensions() :\n                    { rootLeft: 0, rootRight: 0, contentLeft: 0, contentRight: 0 };\n            },\n            getPreviousActiveTabIndex: () => {\n                return this._previousActiveIndex;\n            },\n            getFocusedTabIndex: () => {\n                const tabElements = this._getTabs();\n                const activeElement = this.getRootNode().activeElement;\n                return tabElements.indexOf(activeElement);\n            },\n            getIndexOfTabById: (id) => {\n                const tabElements = this._getTabs();\n                for (let i = 0; i < tabElements.length; i++) {\n                    if (tabElements[i].id === id) {\n                        return i;\n                    }\n                }\n                return -1;\n            },\n            getTabListLength: () => this._getTabs().length,\n            notifyTabActivated: (index) => {\n                // Synchronize the tabs `activeIndex` to the foundation.\n                // This is needed when a tab is changed via a click, for example.\n                this.activeIndex = index;\n                this.dispatchEvent(new CustomEvent(MDCTabBarFoundation.strings.TAB_ACTIVATED_EVENT, { detail: { index }, bubbles: true, cancelable: true }));\n            },\n        };\n    }\n    firstUpdated() {\n        // NOTE: Delay creating foundation until scroller is fully updated.\n        // This is necessary because the foundation/adapter synchronously addresses\n        // the scroller element.\n    }\n    async getUpdateComplete() {\n        const result = await super.getUpdateComplete();\n        await this.scrollerElement.updateComplete;\n        if (this.mdcFoundation === undefined) {\n            this.createFoundation();\n        }\n        return result;\n    }\n    scrollIndexIntoView(index) {\n        this.mdcFoundation.scrollIntoView(index);\n    }\n}\n__decorate([\n    query('.mdc-tab-bar')\n], TabBarBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('mwc-tab-scroller')\n], TabBarBase.prototype, \"scrollerElement\", void 0);\n__decorate([\n    query('slot')\n], TabBarBase.prototype, \"tabsSlot\", void 0);\n__decorate([\n    observer(async function () {\n        await this.updateComplete;\n        // only provoke the foundation if we are out of sync with it, i.e.\n        // ignore an foundation generated set.\n        // use `activeIndex` directly to avoid staleness if it was set before the\n        // first render.\n        if (this.activeIndex !== this._previousActiveIndex) {\n            this.mdcFoundation.activateTab(this.activeIndex);\n        }\n    }),\n    property({ type: Number })\n], TabBarBase.prototype, \"activeIndex\", void 0);\n//# sourceMappingURL=mwc-tab-bar-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport { addHasRemoveClass, BaseElement } from '@material/mwc-base/base-element';\nimport MDCFadingTabIndicatorFoundation from '@material/tab-indicator/fading-foundation';\nimport MDCSlidingTabIndicatorFoundation from '@material/tab-indicator/sliding-foundation';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nexport class TabIndicatorBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.icon = '';\n        this.fade = false;\n    }\n    get mdcFoundationClass() {\n        return this.fade ? MDCFadingTabIndicatorFoundation :\n            MDCSlidingTabIndicatorFoundation;\n    }\n    render() {\n        const contentClasses = {\n            'mdc-tab-indicator__content--icon': this.icon,\n            'material-icons': this.icon,\n            'mdc-tab-indicator__content--underline': !this.icon,\n        };\n        return html `\n      <span class=\"mdc-tab-indicator ${classMap({\n            'mdc-tab-indicator--fade': this.fade\n        })}\">\n        <span class=\"mdc-tab-indicator__content ${classMap(contentClasses)}\">${this.icon}</span>\n      </span>\n      `;\n    }\n    updated(changedProperties) {\n        if (changedProperties.has('fade')) {\n            this.createFoundation();\n        }\n    }\n    createAdapter() {\n        return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { computeContentClientRect: () => this.contentElement.getBoundingClientRect(), setContentStyleProperty: (prop, value) => this.contentElement.style.setProperty(prop, value) });\n    }\n    computeContentClientRect() {\n        return this.mdcFoundation.computeContentClientRect();\n    }\n    activate(previousIndicatorClientRect) {\n        this.mdcFoundation.activate(previousIndicatorClientRect);\n    }\n    deactivate() {\n        this.mdcFoundation.deactivate();\n    }\n}\n__decorate([\n    query('.mdc-tab-indicator')\n], TabIndicatorBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('.mdc-tab-indicator__content')\n], TabIndicatorBase.prototype, \"contentElement\", void 0);\n__decorate([\n    property()\n], TabIndicatorBase.prototype, \"icon\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TabIndicatorBase.prototype, \"fade\", void 0);\n//# sourceMappingURL=mwc-tab-indicator-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n// Make TypeScript not remove the import.\nimport '@material/mwc-tab-indicator';\nimport '@material/mwc-ripple/mwc-ripple';\nimport { addHasRemoveClass, BaseElement } from '@material/mwc-base/base-element';\nimport { observer } from '@material/mwc-base/observer';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers';\nimport MDCTabFoundation from '@material/tab/foundation';\nimport { html } from 'lit';\nimport { eventOptions, property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\n// used for generating unique id for each tab\nlet tabIdCounter = 0;\nexport class TabBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.mdcFoundationClass = MDCTabFoundation;\n        this.label = '';\n        this.icon = '';\n        this.hasImageIcon = false;\n        this.isFadingIndicator = false;\n        this.minWidth = false;\n        this.isMinWidthIndicator = false;\n        this.indicatorIcon = '';\n        this.stacked = false;\n        this.focusOnActivate = true;\n        this._active = false;\n        this.initFocus = false;\n        this.shouldRenderRipple = false;\n        this.useStateLayerCustomProperties = false;\n        this.rippleElement = null;\n        this.rippleHandlers = new RippleHandlers(() => {\n            this.shouldRenderRipple = true;\n            this.ripple.then((v) => this.rippleElement = v);\n            return this.ripple;\n        });\n    }\n    get active() {\n        return this._active;\n    }\n    connectedCallback() {\n        this.dir = document.dir;\n        super.connectedCallback();\n    }\n    firstUpdated() {\n        super.firstUpdated();\n        // create an unique id\n        this.id = this.id || `mdc-tab-${++tabIdCounter}`;\n    }\n    render() {\n        const classes = {\n            'mdc-tab--min-width': this.minWidth,\n            'mdc-tab--stacked': this.stacked,\n        };\n        let iconTemplate = html ``;\n        if (this.hasImageIcon || this.icon) {\n            // NOTE: MUST be on same line as spaces will cause vert alignment issues\n            // in IE\n            iconTemplate = html `\n        <span class=\"mdc-tab__icon material-icons\"><slot name=\"icon\">${this.icon}</slot></span>`;\n        }\n        let labelTemplate = html ``;\n        if (this.label) {\n            labelTemplate = html `\n        <span class=\"mdc-tab__text-label\">${this.label}</span>`;\n        }\n        return html `\n      <button\n        @click=\"${this.handleClick}\"\n        class=\"mdc-tab ${classMap(classes)}\"\n        role=\"tab\"\n        aria-selected=\"false\"\n        tabindex=\"-1\"\n        @focus=\"${this.focus}\"\n        @blur=\"${this.handleBlur}\"\n        @mousedown=\"${this.handleRippleMouseDown}\"\n        @mouseenter=\"${this.handleRippleMouseEnter}\"\n        @mouseleave=\"${this.handleRippleMouseLeave}\"\n        @touchstart=\"${this.handleRippleTouchStart}\"\n        @touchend=\"${this.handleRippleDeactivate}\"\n        @touchcancel=\"${this.handleRippleDeactivate}\">\n        <span class=\"mdc-tab__content\">\n          ${iconTemplate}\n          ${labelTemplate}\n          ${this.isMinWidthIndicator ? this.renderIndicator() : ''}\n        </span>\n        ${this.isMinWidthIndicator ? '' : this.renderIndicator()}\n        ${this.renderRipple()}\n      </button>`;\n    }\n    renderIndicator() {\n        return html `<mwc-tab-indicator\n        .icon=\"${this.indicatorIcon}\"\n        .fade=\"${this.isFadingIndicator}\"></mwc-tab-indicator>`;\n    }\n    // TODO(dfreedm): Make this use selected as a param after Polymer/internal#739\n    /** @soyCompatible */\n    renderRipple() {\n        return this.shouldRenderRipple ?\n            html `<mwc-ripple primary\n        .internalUseStateLayerCustomProperties=\"${this.useStateLayerCustomProperties}\"></mwc-ripple>` :\n            '';\n    }\n    createAdapter() {\n        return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { setAttr: (attr, value) => this.mdcRoot.setAttribute(attr, value), activateIndicator: async (previousIndicatorClientRect) => {\n                await this.tabIndicator.updateComplete;\n                this.tabIndicator.activate(previousIndicatorClientRect);\n            }, deactivateIndicator: async () => {\n                await this.tabIndicator.updateComplete;\n                this.tabIndicator.deactivate();\n            }, notifyInteracted: () => this.dispatchEvent(new CustomEvent(MDCTabFoundation.strings.INTERACTED_EVENT, {\n                detail: { tabId: this.id },\n                bubbles: true,\n                composed: true,\n                cancelable: true,\n            })), getOffsetLeft: () => this.offsetLeft, getOffsetWidth: () => this.mdcRoot.offsetWidth, getContentOffsetLeft: () => this._contentElement.offsetLeft, getContentOffsetWidth: () => this._contentElement.offsetWidth, focus: () => {\n                if (this.initFocus) {\n                    this.initFocus = false;\n                }\n                else {\n                    this.mdcRoot.focus();\n                }\n            } });\n    }\n    activate(clientRect) {\n        // happens only on initialization. We don't want to focus to prevent scroll\n        if (!clientRect) {\n            this.initFocus = true;\n        }\n        if (this.mdcFoundation) {\n            this.mdcFoundation.activate(clientRect);\n            this.setActive(this.mdcFoundation.isActive());\n        }\n        else {\n            // happens if this is called by tab-bar on initialization, but tab has not\n            // finished rendering.\n            this.updateComplete.then(() => {\n                this.mdcFoundation.activate(clientRect);\n                this.setActive(this.mdcFoundation.isActive());\n            });\n        }\n    }\n    deactivate() {\n        this.mdcFoundation.deactivate();\n        this.setActive(this.mdcFoundation.isActive());\n    }\n    setActive(newValue) {\n        const oldValue = this.active;\n        if (oldValue !== newValue) {\n            this._active = newValue;\n            this.requestUpdate('active', oldValue);\n        }\n    }\n    computeDimensions() {\n        return this.mdcFoundation.computeDimensions();\n    }\n    computeIndicatorClientRect() {\n        return this.tabIndicator.computeContentClientRect();\n    }\n    // NOTE: needed only for ShadyDOM where delegatesFocus is not implemented\n    focus() {\n        this.mdcRoot.focus();\n        this.handleFocus();\n    }\n    handleClick() {\n        this.handleFocus();\n        this.mdcFoundation.handleClick();\n    }\n    handleFocus() {\n        this.handleRippleFocus();\n    }\n    handleBlur() {\n        this.handleRippleBlur();\n    }\n    handleRippleMouseDown(event) {\n        const onUp = () => {\n            window.removeEventListener('mouseup', onUp);\n            this.handleRippleDeactivate();\n        };\n        window.addEventListener('mouseup', onUp);\n        this.rippleHandlers.startPress(event);\n    }\n    handleRippleTouchStart(event) {\n        this.rippleHandlers.startPress(event);\n    }\n    handleRippleDeactivate() {\n        this.rippleHandlers.endPress();\n    }\n    handleRippleMouseEnter() {\n        this.rippleHandlers.startHover();\n    }\n    handleRippleMouseLeave() {\n        this.rippleHandlers.endHover();\n    }\n    handleRippleFocus() {\n        this.rippleHandlers.startFocus();\n    }\n    handleRippleBlur() {\n        this.rippleHandlers.endFocus();\n    }\n    get isRippleActive() {\n        var _a;\n        return ((_a = this.rippleElement) === null || _a === void 0 ? void 0 : _a.isActive) || false;\n    }\n}\nTabBase.shadowRootOptions = { mode: 'open', delegatesFocus: true };\n__decorate([\n    query('.mdc-tab')\n], TabBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('mwc-tab-indicator')\n], TabBase.prototype, \"tabIndicator\", void 0);\n__decorate([\n    property()\n], TabBase.prototype, \"label\", void 0);\n__decorate([\n    property()\n], TabBase.prototype, \"icon\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TabBase.prototype, \"hasImageIcon\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TabBase.prototype, \"isFadingIndicator\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TabBase.prototype, \"minWidth\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TabBase.prototype, \"isMinWidthIndicator\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true, attribute: 'active' })\n], TabBase.prototype, \"active\", null);\n__decorate([\n    property()\n], TabBase.prototype, \"indicatorIcon\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TabBase.prototype, \"stacked\", void 0);\n__decorate([\n    observer(async function (value) {\n        await this.updateComplete;\n        this.mdcFoundation.setFocusOnActivate(value);\n    }),\n    property({ type: Boolean })\n], TabBase.prototype, \"focusOnActivate\", void 0);\n__decorate([\n    query('.mdc-tab__content')\n], TabBase.prototype, \"_contentElement\", void 0);\n__decorate([\n    state()\n], TabBase.prototype, \"shouldRenderRipple\", void 0);\n__decorate([\n    state()\n], TabBase.prototype, \"useStateLayerCustomProperties\", void 0);\n__decorate([\n    queryAsync('mwc-ripple')\n], TabBase.prototype, \"ripple\", void 0);\n__decorate([\n    eventOptions({ passive: true })\n], TabBase.prototype, \"handleRippleTouchStart\", null);\n//# sourceMappingURL=mwc-tab-base.js.map","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport { TextFieldBase } from '@material/mwc-textfield/mwc-textfield-base';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { live } from 'lit/directives/live.js';\nconst booleanOrStringConverter = {\n    fromAttribute(value) {\n        if (value === null) {\n            return false;\n        }\n        else if (value === '') {\n            return true;\n        }\n        return value;\n    },\n    toAttribute(value) {\n        if (typeof value === 'boolean') {\n            return value ? '' : null;\n        }\n        return value;\n    }\n};\n/** @soyCompatible */\nexport class TextAreaBase extends TextFieldBase {\n    constructor() {\n        super(...arguments);\n        this.rows = 2;\n        this.cols = 20;\n        this.charCounter = false;\n    }\n    /** @soyTemplate */\n    render() {\n        const shouldRenderCharCounter = this.charCounter && this.maxLength !== -1;\n        const shouldRenderInternalCharCounter = shouldRenderCharCounter && this.charCounter === 'internal';\n        const shouldRenderExternalCharCounter = shouldRenderCharCounter && !shouldRenderInternalCharCounter;\n        const shouldRenderHelperText = !!this.helper || !!this.validationMessage ||\n            shouldRenderExternalCharCounter;\n        /** @classMap */\n        const classes = {\n            'mdc-text-field--disabled': this.disabled,\n            'mdc-text-field--no-label': !this.label,\n            'mdc-text-field--filled': !this.outlined,\n            'mdc-text-field--outlined': this.outlined,\n            'mdc-text-field--end-aligned': this.endAligned,\n            'mdc-text-field--with-internal-counter': shouldRenderInternalCharCounter,\n        };\n        return html `\n      <label class=\"mdc-text-field mdc-text-field--textarea ${classMap(classes)}\">\n        ${this.renderRipple()}\n        ${this.outlined ? this.renderOutline() : this.renderLabel()}\n        ${this.renderInput()}\n        ${this.renderCharCounter(shouldRenderInternalCharCounter)}\n        ${this.renderLineRipple()}\n      </label>\n      ${this.renderHelperText(shouldRenderHelperText, shouldRenderExternalCharCounter)}\n    `;\n    }\n    /** @soyTemplate */\n    renderInput() {\n        const ariaLabelledbyOrUndef = !!this.label ? 'label' : undefined;\n        const minOrUndef = this.minLength === -1 ? undefined : this.minLength;\n        const maxOrUndef = this.maxLength === -1 ? undefined : this.maxLength;\n        const autocapitalizeOrUndef = this.autocapitalize ?\n            this.autocapitalize :\n            undefined;\n        return html `\n      <textarea\n          aria-labelledby=${ifDefined(ariaLabelledbyOrUndef)}\n          class=\"mdc-text-field__input\"\n          .value=\"${live(this.value)}\"\n          rows=\"${this.rows}\"\n          cols=\"${this.cols}\"\n          ?disabled=\"${this.disabled}\"\n          placeholder=\"${this.placeholder}\"\n          ?required=\"${this.required}\"\n          ?readonly=\"${this.readOnly}\"\n          minlength=\"${ifDefined(minOrUndef)}\"\n          maxlength=\"${ifDefined(maxOrUndef)}\"\n          name=\"${ifDefined(this.name === '' ? undefined : this.name)}\"\n          inputmode=\"${ifDefined(this.inputMode)}\"\n          autocapitalize=\"${ifDefined(autocapitalizeOrUndef)}\"\n          @input=\"${this.handleInputChange}\"\n          @blur=\"${this.onInputBlur}\">\n      </textarea>`;\n    }\n}\n__decorate([\n    query('textarea')\n], TextAreaBase.prototype, \"formElement\", void 0);\n__decorate([\n    property({ type: Number })\n], TextAreaBase.prototype, \"rows\", void 0);\n__decorate([\n    property({ type: Number })\n], TextAreaBase.prototype, \"cols\", void 0);\n__decorate([\n    property({ converter: booleanOrStringConverter })\n], TextAreaBase.prototype, \"charCounter\", void 0);\n//# sourceMappingURL=mwc-textarea-base.js.map","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-notched-outline';\nimport { addHasRemoveClass, FormElement } from '@material/mwc-base/form-element';\nimport { observer } from '@material/mwc-base/observer';\nimport { floatingLabel } from '@material/mwc-floating-label';\nimport { lineRipple } from '@material/mwc-line-ripple';\nimport MDCTextFieldFoundation from '@material/textfield/foundation';\nimport { html } from 'lit';\nimport { eventOptions, property, query, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { live } from 'lit/directives/live.js';\nconst passiveEvents = ['touchstart', 'touchmove', 'scroll', 'mousewheel'];\nconst createValidityObj = (customValidity = {}) => {\n    /*\n     * We need to make ValidityState an object because it is readonly and\n     * we cannot use the spread operator. Also, we don't export\n     * `CustomValidityState` because it is a leaky implementation and the user\n     * already has access to `ValidityState` in lib.dom.ts. Also an interface\n     * {a: Type} can be casted to {readonly a: Type} so passing any object\n     * should be fine.\n     */\n    const objectifiedCustomValidity = {};\n    // eslint-disable-next-line guard-for-in\n    for (const propName in customValidity) {\n        /*\n         * Casting is needed because ValidityState's props are all readonly and\n         * thus cannot be set on `onjectifiedCustomValidity`. In the end, the\n         * interface is the same as ValidityState (but not readonly), but the\n         * function signature casts the output to ValidityState (thus readonly).\n         */\n        objectifiedCustomValidity[propName] =\n            customValidity[propName];\n    }\n    return Object.assign({ badInput: false, customError: false, patternMismatch: false, rangeOverflow: false, rangeUnderflow: false, stepMismatch: false, tooLong: false, tooShort: false, typeMismatch: false, valid: true, valueMissing: false }, objectifiedCustomValidity);\n};\n/** @soyCompatible */\nexport class TextFieldBase extends FormElement {\n    constructor() {\n        super(...arguments);\n        this.mdcFoundationClass = MDCTextFieldFoundation;\n        this.value = '';\n        this.type = 'text';\n        this.placeholder = '';\n        this.label = '';\n        this.icon = '';\n        this.iconTrailing = '';\n        this.disabled = false;\n        this.required = false;\n        this.minLength = -1;\n        this.maxLength = -1;\n        this.outlined = false;\n        this.helper = '';\n        this.validateOnInitialRender = false;\n        this.validationMessage = '';\n        this.autoValidate = false;\n        this.pattern = '';\n        this.min = '';\n        this.max = '';\n        /**\n         * step can be a number or the keyword \"any\".\n         *\n         * Use `String` typing to pass down the value as a string and let the native\n         * input cast internally as needed.\n         */\n        this.step = null;\n        this.size = null;\n        this.helperPersistent = false;\n        this.charCounter = false;\n        this.endAligned = false;\n        this.prefix = '';\n        this.suffix = '';\n        this.name = '';\n        this.readOnly = false;\n        this.autocapitalize = '';\n        this.outlineOpen = false;\n        this.outlineWidth = 0;\n        this.isUiValid = true;\n        this.focused = false;\n        this._validity = createValidityObj();\n        this.validityTransform = null;\n    }\n    get validity() {\n        this._checkValidity(this.value);\n        return this._validity;\n    }\n    get willValidate() {\n        return this.formElement.willValidate;\n    }\n    get selectionStart() {\n        return this.formElement.selectionStart;\n    }\n    get selectionEnd() {\n        return this.formElement.selectionEnd;\n    }\n    focus() {\n        const focusEvt = new CustomEvent('focus');\n        this.formElement.dispatchEvent(focusEvt);\n        this.formElement.focus();\n    }\n    blur() {\n        const blurEvt = new CustomEvent('blur');\n        this.formElement.dispatchEvent(blurEvt);\n        this.formElement.blur();\n    }\n    select() {\n        this.formElement.select();\n    }\n    setSelectionRange(selectionStart, selectionEnd, selectionDirection) {\n        this.formElement.setSelectionRange(selectionStart, selectionEnd, selectionDirection);\n    }\n    update(changedProperties) {\n        if (changedProperties.has('autoValidate') && this.mdcFoundation) {\n            this.mdcFoundation.setValidateOnValueChange(this.autoValidate);\n        }\n        if (changedProperties.has('value') && typeof this.value !== 'string') {\n            this.value = `${this.value}`;\n        }\n        super.update(changedProperties);\n    }\n    setFormData(formData) {\n        if (this.name) {\n            formData.append(this.name, this.value);\n        }\n    }\n    /** @soyTemplate */\n    render() {\n        const shouldRenderCharCounter = this.charCounter && this.maxLength !== -1;\n        const shouldRenderHelperText = !!this.helper || !!this.validationMessage || shouldRenderCharCounter;\n        /** @classMap */\n        const classes = {\n            'mdc-text-field--disabled': this.disabled,\n            'mdc-text-field--no-label': !this.label,\n            'mdc-text-field--filled': !this.outlined,\n            'mdc-text-field--outlined': this.outlined,\n            'mdc-text-field--with-leading-icon': this.icon,\n            'mdc-text-field--with-trailing-icon': this.iconTrailing,\n            'mdc-text-field--end-aligned': this.endAligned,\n        };\n        return html `\n      <label class=\"mdc-text-field ${classMap(classes)}\">\n        ${this.renderRipple()}\n        ${this.outlined ? this.renderOutline() : this.renderLabel()}\n        ${this.renderLeadingIcon()}\n        ${this.renderPrefix()}\n        ${this.renderInput(shouldRenderHelperText)}\n        ${this.renderSuffix()}\n        ${this.renderTrailingIcon()}\n        ${this.renderLineRipple()}\n      </label>\n      ${this.renderHelperText(shouldRenderHelperText, shouldRenderCharCounter)}\n    `;\n    }\n    updated(changedProperties) {\n        if (changedProperties.has('value') &&\n            changedProperties.get('value') !== undefined) {\n            this.mdcFoundation.setValue(this.value);\n            if (this.autoValidate) {\n                this.reportValidity();\n            }\n        }\n    }\n    /** @soyTemplate */\n    renderRipple() {\n        return this.outlined ? '' : html `\n      <span class=\"mdc-text-field__ripple\"></span>\n    `;\n    }\n    /** @soyTemplate */\n    renderOutline() {\n        return !this.outlined ? '' : html `\n      <mwc-notched-outline\n          .width=${this.outlineWidth}\n          .open=${this.outlineOpen}\n          class=\"mdc-notched-outline\">\n        ${this.renderLabel()}\n      </mwc-notched-outline>`;\n    }\n    /** @soyTemplate */\n    renderLabel() {\n        return !this.label ?\n            '' :\n            html `\n      <span\n          .floatingLabelFoundation=${floatingLabel(this.label)}\n          id=\"label\">${this.label}</span>\n    `;\n    }\n    /** @soyTemplate */\n    renderLeadingIcon() {\n        return this.icon ? this.renderIcon(this.icon) : '';\n    }\n    /** @soyTemplate */\n    renderTrailingIcon() {\n        return this.iconTrailing ? this.renderIcon(this.iconTrailing, true) : '';\n    }\n    /** @soyTemplate */\n    renderIcon(icon, isTrailingIcon = false) {\n        /** @classMap */\n        const classes = {\n            'mdc-text-field__icon--leading': !isTrailingIcon,\n            'mdc-text-field__icon--trailing': isTrailingIcon\n        };\n        return html `<i class=\"material-icons mdc-text-field__icon ${classMap(classes)}\">${icon}</i>`;\n    }\n    /** @soyTemplate */\n    renderPrefix() {\n        return this.prefix ? this.renderAffix(this.prefix) : '';\n    }\n    /** @soyTemplate */\n    renderSuffix() {\n        return this.suffix ? this.renderAffix(this.suffix, true) : '';\n    }\n    /** @soyTemplate */\n    renderAffix(content, isSuffix = false) {\n        /** @classMap */\n        const classes = {\n            'mdc-text-field__affix--prefix': !isSuffix,\n            'mdc-text-field__affix--suffix': isSuffix\n        };\n        return html `<span class=\"mdc-text-field__affix ${classMap(classes)}\">\n        ${content}</span>`;\n    }\n    /** @soyTemplate */\n    renderInput(shouldRenderHelperText) {\n        const minOrUndef = this.minLength === -1 ? undefined : this.minLength;\n        const maxOrUndef = this.maxLength === -1 ? undefined : this.maxLength;\n        const autocapitalizeOrUndef = this.autocapitalize ?\n            this.autocapitalize :\n            undefined;\n        const showValidationMessage = this.validationMessage && !this.isUiValid;\n        const ariaLabelledbyOrUndef = !!this.label ? 'label' : undefined;\n        const ariaControlsOrUndef = shouldRenderHelperText ? 'helper-text' : undefined;\n        const ariaDescribedbyOrUndef = this.focused || this.helperPersistent || showValidationMessage ?\n            'helper-text' :\n            undefined;\n        // TODO: live() directive needs casting for lit-analyzer\n        // https://github.com/runem/lit-analyzer/pull/91/files\n        // TODO: lit-analyzer labels min/max as (number|string) instead of string\n        return html `\n      <input\n          aria-labelledby=${ifDefined(ariaLabelledbyOrUndef)}\n          aria-controls=\"${ifDefined(ariaControlsOrUndef)}\"\n          aria-describedby=\"${ifDefined(ariaDescribedbyOrUndef)}\"\n          class=\"mdc-text-field__input\"\n          type=\"${this.type}\"\n          .value=\"${live(this.value)}\"\n          ?disabled=\"${this.disabled}\"\n          placeholder=\"${this.placeholder}\"\n          ?required=\"${this.required}\"\n          ?readonly=\"${this.readOnly}\"\n          minlength=\"${ifDefined(minOrUndef)}\"\n          maxlength=\"${ifDefined(maxOrUndef)}\"\n          pattern=\"${ifDefined(this.pattern ? this.pattern : undefined)}\"\n          min=\"${ifDefined(this.min === '' ? undefined : this.min)}\"\n          max=\"${ifDefined(this.max === '' ? undefined : this.max)}\"\n          step=\"${ifDefined(this.step === null ? undefined : this.step)}\"\n          size=\"${ifDefined(this.size === null ? undefined : this.size)}\"\n          name=\"${ifDefined(this.name === '' ? undefined : this.name)}\"\n          inputmode=\"${ifDefined(this.inputMode)}\"\n          autocapitalize=\"${ifDefined(autocapitalizeOrUndef)}\"\n          @input=\"${this.handleInputChange}\"\n          @focus=\"${this.onInputFocus}\"\n          @blur=\"${this.onInputBlur}\">`;\n    }\n    /** @soyTemplate */\n    renderLineRipple() {\n        return this.outlined ?\n            '' :\n            html `\n      <span .lineRippleFoundation=${lineRipple()}></span>\n    `;\n    }\n    /** @soyTemplate */\n    renderHelperText(shouldRenderHelperText, shouldRenderCharCounter) {\n        const showValidationMessage = this.validationMessage && !this.isUiValid;\n        /** @classMap */\n        const classes = {\n            'mdc-text-field-helper-text--persistent': this.helperPersistent,\n            'mdc-text-field-helper-text--validation-msg': showValidationMessage,\n        };\n        const ariaHiddenOrUndef = this.focused || this.helperPersistent || showValidationMessage ?\n            undefined :\n            'true';\n        const helperText = showValidationMessage ? this.validationMessage : this.helper;\n        return !shouldRenderHelperText ? '' : html `\n      <div class=\"mdc-text-field-helper-line\">\n        <div id=\"helper-text\"\n             aria-hidden=\"${ifDefined(ariaHiddenOrUndef)}\"\n             class=\"mdc-text-field-helper-text ${classMap(classes)}\"\n             >${helperText}</div>\n        ${this.renderCharCounter(shouldRenderCharCounter)}\n      </div>`;\n    }\n    /** @soyTemplate */\n    renderCharCounter(shouldRenderCharCounter) {\n        const length = Math.min(this.value.length, this.maxLength);\n        return !shouldRenderCharCounter ? '' : html `\n      <span class=\"mdc-text-field-character-counter\"\n            >${length} / ${this.maxLength}</span>`;\n    }\n    onInputFocus() {\n        this.focused = true;\n    }\n    onInputBlur() {\n        this.focused = false;\n        this.reportValidity();\n    }\n    checkValidity() {\n        const isValid = this._checkValidity(this.value);\n        if (!isValid) {\n            const invalidEvent = new Event('invalid', { bubbles: false, cancelable: true });\n            this.dispatchEvent(invalidEvent);\n        }\n        return isValid;\n    }\n    reportValidity() {\n        const isValid = this.checkValidity();\n        this.mdcFoundation.setValid(isValid);\n        this.isUiValid = isValid;\n        return isValid;\n    }\n    _checkValidity(value) {\n        const nativeValidity = this.formElement.validity;\n        let validity = createValidityObj(nativeValidity);\n        if (this.validityTransform) {\n            const customValidity = this.validityTransform(value, validity);\n            validity = Object.assign(Object.assign({}, validity), customValidity);\n            this.mdcFoundation.setUseNativeValidation(false);\n        }\n        else {\n            this.mdcFoundation.setUseNativeValidation(true);\n        }\n        this._validity = validity;\n        return this._validity.valid;\n    }\n    setCustomValidity(message) {\n        this.validationMessage = message;\n        this.formElement.setCustomValidity(message);\n    }\n    handleInputChange() {\n        this.value = this.formElement.value;\n    }\n    createAdapter() {\n        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.getRootAdapterMethods()), this.getInputAdapterMethods()), this.getLabelAdapterMethods()), this.getLineRippleAdapterMethods()), this.getOutlineAdapterMethods());\n    }\n    getRootAdapterMethods() {\n        return Object.assign({ registerTextFieldInteractionHandler: (evtType, handler) => this.addEventListener(evtType, handler), deregisterTextFieldInteractionHandler: (evtType, handler) => this.removeEventListener(evtType, handler), registerValidationAttributeChangeHandler: (handler) => {\n                const getAttributesList = (mutationsList) => {\n                    return mutationsList.map((mutation) => mutation.attributeName)\n                        .filter((attributeName) => attributeName);\n                };\n                const observer = new MutationObserver((mutationsList) => {\n                    handler(getAttributesList(mutationsList));\n                });\n                const config = { attributes: true };\n                observer.observe(this.formElement, config);\n                return observer;\n            }, deregisterValidationAttributeChangeHandler: (observer) => observer.disconnect() }, addHasRemoveClass(this.mdcRoot));\n    }\n    getInputAdapterMethods() {\n        return {\n            getNativeInput: () => this.formElement,\n            // since HelperTextFoundation is not used, aria-describedby a11y logic\n            // is implemented in render method instead of these adapter methods\n            setInputAttr: () => undefined,\n            removeInputAttr: () => undefined,\n            isFocused: () => this.shadowRoot ?\n                this.shadowRoot.activeElement === this.formElement :\n                false,\n            registerInputInteractionHandler: (evtType, handler) => this.formElement.addEventListener(evtType, handler, { passive: evtType in passiveEvents }),\n            deregisterInputInteractionHandler: (evtType, handler) => this.formElement.removeEventListener(evtType, handler),\n        };\n    }\n    getLabelAdapterMethods() {\n        return {\n            floatLabel: (shouldFloat) => this.labelElement &&\n                this.labelElement.floatingLabelFoundation.float(shouldFloat),\n            getLabelWidth: () => {\n                return this.labelElement ?\n                    this.labelElement.floatingLabelFoundation.getWidth() :\n                    0;\n            },\n            hasLabel: () => Boolean(this.labelElement),\n            shakeLabel: (shouldShake) => this.labelElement &&\n                this.labelElement.floatingLabelFoundation.shake(shouldShake),\n            setLabelRequired: (isRequired) => {\n                if (this.labelElement) {\n                    this.labelElement.floatingLabelFoundation.setRequired(isRequired);\n                }\n            },\n        };\n    }\n    getLineRippleAdapterMethods() {\n        return {\n            activateLineRipple: () => {\n                if (this.lineRippleElement) {\n                    this.lineRippleElement.lineRippleFoundation.activate();\n                }\n            },\n            deactivateLineRipple: () => {\n                if (this.lineRippleElement) {\n                    this.lineRippleElement.lineRippleFoundation.deactivate();\n                }\n            },\n            setLineRippleTransformOrigin: (normalizedX) => {\n                if (this.lineRippleElement) {\n                    this.lineRippleElement.lineRippleFoundation.setRippleCenter(normalizedX);\n                }\n            },\n        };\n    }\n    // tslint:disable:ban-ts-ignore\n    async getUpdateComplete() {\n        var _a;\n        // @ts-ignore\n        const result = await super.getUpdateComplete();\n        await ((_a = this.outlineElement) === null || _a === void 0 ? void 0 : _a.updateComplete);\n        return result;\n    }\n    // tslint:enable:ban-ts-ignore\n    firstUpdated() {\n        var _a;\n        super.firstUpdated();\n        this.mdcFoundation.setValidateOnValueChange(this.autoValidate);\n        if (this.validateOnInitialRender) {\n            this.reportValidity();\n        }\n        // wait for the outline element to render to update the notch width\n        (_a = this.outlineElement) === null || _a === void 0 ? void 0 : _a.updateComplete.then(() => {\n            var _a;\n            // `foundation.notchOutline()` assumes the label isn't floating and\n            // multiplies by a constant, but the label is already is floating at this\n            // stage, therefore directly set the outline width to the label width\n            this.outlineWidth =\n                ((_a = this.labelElement) === null || _a === void 0 ? void 0 : _a.floatingLabelFoundation.getWidth()) || 0;\n        });\n    }\n    getOutlineAdapterMethods() {\n        return {\n            closeOutline: () => this.outlineElement && (this.outlineOpen = false),\n            hasOutline: () => Boolean(this.outlineElement),\n            notchOutline: (labelWidth) => {\n                const outlineElement = this.outlineElement;\n                if (outlineElement && !this.outlineOpen) {\n                    this.outlineWidth = labelWidth;\n                    this.outlineOpen = true;\n                }\n            }\n        };\n    }\n    async layout() {\n        await this.updateComplete;\n        const labelElement = this.labelElement;\n        if (!labelElement) {\n            this.outlineOpen = false;\n            return;\n        }\n        const shouldFloat = !!this.label && !!this.value;\n        labelElement.floatingLabelFoundation.float(shouldFloat);\n        if (!this.outlined) {\n            return;\n        }\n        this.outlineOpen = shouldFloat;\n        await this.updateComplete;\n        /* When the textfield automatically notches due to a value and label\n         * being defined, the textfield may be set to `display: none` by the user.\n         * this means that the notch is of size 0px. We provide this function so\n         * that the user may manually resize the notch to the floated label's\n         * width.\n         */\n        const labelWidth = labelElement.floatingLabelFoundation.getWidth();\n        if (this.outlineOpen) {\n            this.outlineWidth = labelWidth;\n            await this.updateComplete;\n        }\n    }\n}\n__decorate([\n    query('.mdc-text-field')\n], TextFieldBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('input')\n], TextFieldBase.prototype, \"formElement\", void 0);\n__decorate([\n    query('.mdc-floating-label')\n], TextFieldBase.prototype, \"labelElement\", void 0);\n__decorate([\n    query('.mdc-line-ripple')\n], TextFieldBase.prototype, \"lineRippleElement\", void 0);\n__decorate([\n    query('mwc-notched-outline')\n], TextFieldBase.prototype, \"outlineElement\", void 0);\n__decorate([\n    query('.mdc-notched-outline__notch')\n], TextFieldBase.prototype, \"notchElement\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"value\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"type\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"placeholder\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (_newVal, oldVal) {\n        if (oldVal !== undefined && this.label !== oldVal) {\n            this.layout();\n        }\n    })\n], TextFieldBase.prototype, \"label\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"icon\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"iconTrailing\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], TextFieldBase.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TextFieldBase.prototype, \"required\", void 0);\n__decorate([\n    property({ type: Number })\n], TextFieldBase.prototype, \"minLength\", void 0);\n__decorate([\n    property({ type: Number })\n], TextFieldBase.prototype, \"maxLength\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true }),\n    observer(function (_newVal, oldVal) {\n        if (oldVal !== undefined && this.outlined !== oldVal) {\n            this.layout();\n        }\n    })\n], TextFieldBase.prototype, \"outlined\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"helper\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TextFieldBase.prototype, \"validateOnInitialRender\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"validationMessage\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TextFieldBase.prototype, \"autoValidate\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"pattern\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"min\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"max\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"step\", void 0);\n__decorate([\n    property({ type: Number })\n], TextFieldBase.prototype, \"size\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TextFieldBase.prototype, \"helperPersistent\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TextFieldBase.prototype, \"charCounter\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TextFieldBase.prototype, \"endAligned\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"prefix\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"suffix\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"name\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"inputMode\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TextFieldBase.prototype, \"readOnly\", void 0);\n__decorate([\n    property({ type: String })\n], TextFieldBase.prototype, \"autocapitalize\", void 0);\n__decorate([\n    state()\n], TextFieldBase.prototype, \"outlineOpen\", void 0);\n__decorate([\n    state()\n], TextFieldBase.prototype, \"outlineWidth\", void 0);\n__decorate([\n    state()\n], TextFieldBase.prototype, \"isUiValid\", void 0);\n__decorate([\n    state()\n], TextFieldBase.prototype, \"focused\", void 0);\n__decorate([\n    eventOptions({ passive: true })\n], TextFieldBase.prototype, \"handleInputChange\", null);\n//# sourceMappingURL=mwc-textfield-base.js.map","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport { addHasRemoveClass, BaseElement } from '@material/mwc-base/base-element';\nimport { supportsPassiveEventListener } from '@material/mwc-base/utils';\nimport { strings } from '@material/top-app-bar/constants';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nexport const passiveEventOptionsIfSupported = supportsPassiveEventListener ? { passive: true } : undefined;\nexport class TopAppBarBaseBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.centerTitle = false;\n        this.handleTargetScroll = () => {\n            this.mdcFoundation.handleTargetScroll();\n        };\n        this.handleNavigationClick = () => {\n            this.mdcFoundation.handleNavigationClick();\n        };\n    }\n    get scrollTarget() {\n        return this._scrollTarget || window;\n    }\n    set scrollTarget(value) {\n        this.unregisterScrollListener();\n        const old = this.scrollTarget;\n        this._scrollTarget = value;\n        this.updateRootPosition();\n        this.requestUpdate('scrollTarget', old);\n        this.registerScrollListener();\n    }\n    updateRootPosition() {\n        if (this.mdcRoot) {\n            const windowScroller = this.scrollTarget === window;\n            // we add support for top-app-bar's tied to an element scroller.\n            this.mdcRoot.style.position = windowScroller ? '' : 'absolute';\n        }\n    }\n    render() {\n        // clang-format off\n        let title = html `<span class=\"mdc-top-app-bar__title\"><slot name=\"title\"></slot></span>`;\n        if (this.centerTitle) {\n            title = html `<section class=\"mdc-top-app-bar__section mdc-top-app-bar__section--align-center\">${title}</section>`;\n        }\n        // clang-format on\n        return html `\n      <header class=\"mdc-top-app-bar ${classMap(this.barClasses())}\">\n      <div class=\"mdc-top-app-bar__row\">\n        <section class=\"mdc-top-app-bar__section mdc-top-app-bar__section--align-start\" id=\"navigation\">\n          <slot name=\"navigationIcon\"\n            @click=${this.handleNavigationClick}></slot>\n          ${this.centerTitle ? null : title}\n        </section>\n        ${this.centerTitle ? title : null}\n        <section class=\"mdc-top-app-bar__section mdc-top-app-bar__section--align-end\" id=\"actions\" role=\"toolbar\">\n          <slot name=\"actionItems\"></slot>\n        </section>\n      </div>\n    </header>\n    <div class=\"${classMap(this.contentClasses())}\">\n      <slot></slot>\n    </div>\n    `;\n    }\n    createAdapter() {\n        return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { setStyle: (property, value) => this.mdcRoot.style.setProperty(property, value), getTopAppBarHeight: () => this.mdcRoot.clientHeight, notifyNavigationIconClicked: () => {\n                this.dispatchEvent(new Event(strings.NAVIGATION_EVENT, { bubbles: true, cancelable: true }));\n            }, getViewportScrollY: () => this.scrollTarget instanceof Window ?\n                this.scrollTarget.pageYOffset :\n                this.scrollTarget.scrollTop, getTotalActionItems: () => this._actionItemsSlot\n                .assignedNodes({ flatten: true })\n                .length });\n    }\n    registerListeners() {\n        this.registerScrollListener();\n    }\n    unregisterListeners() {\n        this.unregisterScrollListener();\n    }\n    registerScrollListener() {\n        this.scrollTarget.addEventListener('scroll', this.handleTargetScroll, passiveEventOptionsIfSupported);\n    }\n    unregisterScrollListener() {\n        this.scrollTarget.removeEventListener('scroll', this.handleTargetScroll);\n    }\n    firstUpdated() {\n        super.firstUpdated();\n        this.updateRootPosition();\n        this.registerListeners();\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.unregisterListeners();\n    }\n}\n__decorate([\n    query('.mdc-top-app-bar')\n], TopAppBarBaseBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('slot[name=\"actionItems\"]')\n], TopAppBarBaseBase.prototype, \"_actionItemsSlot\", void 0);\n__decorate([\n    property({ type: Boolean })\n], TopAppBarBaseBase.prototype, \"centerTitle\", void 0);\n__decorate([\n    property({ type: Object })\n], TopAppBarBaseBase.prototype, \"scrollTarget\", null);\n//# sourceMappingURL=mwc-top-app-bar-base-base.js.map"],"names":[],"sourceRoot":""}